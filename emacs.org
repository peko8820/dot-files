#+TITLE:  Emacs Configuration File
#+AUTHOR: Markus Sievers
#+EMAIL:  markussievers88@gmail.com
#+DATE:   [2016-05-19]
#+TAGS:   emacs

* Introduction

  This is my =.emacs= file ... well, I took Howard Abrams emacs.org as
  an example and created this top-level init-file. Through Howard I
  was introduced to [[http://www.literateprogramming.com/][literate_programming]] using Emacs' [[http://www.orgmode.org][orgmode]]. I will
  try to provide the links as best as I can to show from where I stole
  my notes.

** Emacs Executable

   If you want to install Emacs on Ubuntu all you have to do is run
   this from the terminal to install the pre-compiled version
   included in the Ubuntu repository:

   #+BEGIN_SRC sh :tangle no
     sudo apt-get update
     sudo apt-get install emacs -y
   #+END_SRC

   You may, of course, get the source code and compile it
   yourself. But for me using the pre-compiled version is sufficient
   because I do not have to fight around with dependency issues.

   In case you are one of the unfortunate ones that have use a windows
   operating system you have the option to download an Emacs
   compilation from one of the gnu mirrors. The
   [[http://www.gnu.org/software/emacs/manual/html_mono/efaq-w32.html][GNU_Emacs_FAQ_for_MS_Windows]] section on the [[http://www.gnu.org/software/emacs/manual/][GNU_Emacs_Online_Manual]]
   web page will lead to to the nearest mirror where you can download
   the latest compiled version of Emacs. Once you downloaded and
   unpacked the /Zip/ file you have to do a few more modifications:

      1) Rename and copy the unpacked Emacs folder to your /Program
         Files/ or /Program Files (x86)/ folder.
      2) Add the /bin/ sub-directory to the /PATH/ variable.
      3) Create the /HOME/ variable in your windows variables pointing
         to your /$HOME/ directory (Typically located at C:/Users/username/)
      4) Within the /bin/ sub-directory execute the /addpm.exe/
         program as an administrator to "install" Emacs.
      5) I like to enable the *Run as administrator* option for the
         /emacs.exe/ and /runemacs.exe/ file such that I have root
         access rights when running commands from within Emacs.

   The previous steps are also nicely visualized in this YouTube
   tutorial:

   [[https://youtu.be/g6kgF5ZAf44][How_to_Install_Emacs_editor_in_Windows]]

** Loading this File

   To "load" the contents of this file, add the following to
   =$HOME/.emacs=:

   #+BEGIN_SRC elisp :tangle no
     ;; Load our Literate Programming version of our Dot Emacs
     ;; file, from ~/Path_to/Dot-Files/emacs.org
     (load-file "~/.emacs.d/elisp/init-main.el")

     (server-start)
   #+END_SRC

* General Settings

** Setting the input format

   This is a short but nonetheless import one. To use all of the
   Unicode character richness I need to make sure to set some
   defaults:

   #+BEGIN_SRC elisp
     (set-language-environment "UTF-8")
     (set-default-coding-systems 'utf-8)
   #+END_SRC

** Setting up the =$PATH= variable

   In case I use Emacs on a windows computer I need to take care that
   I have the necessary directories added to the =exec-path=
   variable. At this moment I manually add the directories with the
   following functions:

   #+BEGIN_SRC elisp
     (when (eq system-type 'windows-nt)
       (setenv "PATH" (mapconcat 'identity ms/PATH_on_Windows ";") )
       (setq exec-path (append ms/PATH_on_Windows (list "." exec-directory))))
   #+END_SRC

   I recently discovered the =exec-from-shell= package because I was
   having trouble synchronizing the modifications I had mad to the
   ~$PATH~ variable in my =.bashrc=. By simply initializing the package
   the problem seems to be solved.

   #+BEGIN_SRC elisp
     (when (eq system-type 'gnu/linux)
       (exec-path-from-shell-initialize))
   #+END_SRC

** My Directory Location

   Normally, the =user-emacs-directory= stores everything in a
   =.emacs.d= directory in the home directory, however, some Emacs
   flavors (e.g. Aquamacs) overrides that, and since I now feel the
   need to use these settings for both editors (sure feels like XEmacs
   all over again).

   Any way, I have a new global variable for that:

   #+BEGIN_SRC elisp
     (defconst ms/emacs-directory (concat (getenv "HOME") "/.emacs.d/"))

     (defun ms/emacs-subdirectory (d) (expand-file-name d ms/emacs-directory))
   #+END_SRC

** Directory Structure

   In case this is the first time running this on a computer, we need
   to make sure the following directories have been created.

   #+BEGIN_SRC elisp
     (let* ((subdirs '("elisp" "backups" "snippets" "ac-dict"))
            (fulldirs (mapcar (lambda (d) (ms/emacs-subdirectory d)) subdirs)))
       (dolist (dir fulldirs)
         (when (not (file-exists-p dir))
           (message "Make directory: %s" dir)
           (make-directory dir))))
   #+END_SRC

** Customization Section

   While I would rather program my configurations, sometimes the Emacs
   menu system is "good enough", but I want it in its own file:

   #+BEGIN_SRC elisp
     (setq custom-file (expand-file-name "custom.el" ms/emacs-directory))
     (when (file-exists-p custom-file)
       (load custom-file))
   #+END_SRC

** Setting up the Load Path

   Extra packages not available via the package manager go in my
   personal stash at: =$HOME/.emacs.d/elisp=

   #+BEGIN_SRC elisp
     (add-to-list 'load-path (ms/emacs-subdirectory "elisp"))
   #+END_SRC

   Load up my special collection of enhancements to Emacs Lisp ([[file:emacs-support.org][emacs-support.org]]):

   #+BEGIN_SRC elisp
     (require 'cl)
     (require 'init-support)
   #+END_SRC

** Local Configurations

   Before we finish, we need to check if there is a local file for us
   to load and evaluate.  We assume the local file has been tangled
   and provides the =init-local= key:

   #+BEGIN_SRC elisp
     (require 'init-local nil t)
   #+END_SRC

* Package Initialization
** Package Manager

   Emacs has become like every other operating system, and now has a
   [[http://tromey.com/elpa/][package manager]] with its own collection repository, but since it is
   so conservative, we need to add more repositories to get all the
   sweet goodness, I demand. But before I can get a hold of all those
   glorious packages I need to make sure that I can get through the
   proxy at work, but only at work:

   #+BEGIN_SRC elisp
     ;; Make sure that we can get through the proxy at work,
     ;; but only at work
     (if (string= user-login-name 'sieversm)
         (setq url-proxy-services
              '(("http" . ms/proxy-ip)
                ("https" . ms/proxy-ip)))
      'false)
   #+END_SRC

   Now I can get to all the juicy stuff:

   #+BEGIN_SRC elisp
     (require 'package)

     (setq package-archives '(("org"       . "http://orgmode.org/elpa/")
                              ("gnu"       . "http://elpa.gnu.org/packages/")
                              ("melpa"     . "http://melpa.org/packages/")))

     (package-initialize)
   #+END_SRC

   These is also the *marmalade* repository, but I have only bad
   things about it. Thus I am not including it here. If you want to
   add the following to the previous archive list:

   #+BEGIN_SRC elisp :tangle no
     ("marmalade" . "http://marmalade-repo.org/packages/")
   #+END_SRC

   The package management system doesn't come with a
   programmatic way to specify what packages /should/ be
   installed. Here is my solution until I convert to [[Use-Package][use-package]].

   #+BEGIN_SRC elisp
     (defun packages-install (packages)
       "Given a list of packages, this will install them from the standard locations."
       (let ((to-install (inverse-filter 'package-installed-p packages)))
         (when to-install
           (package-refresh-contents)
           (dolist (it to-install)
               (package-install it)
           (delete-other-windows)))))
   #+END_SRC

** Use-Package

   Using [[https://github.com/jwiegley/use-package][use-package]] to automatically install certain packages, as
   well as the ease of lazily loading them.

   #+BEGIN_SRC elisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (require 'use-package)
   #+END_SRC

* Variables

  Generall setting about me that other packages can use.  Because I
  like my time settings to be in English even if I am working on a
  machine with different language settings is set the
  =system-time-locale= variable:

  #+BEGIN_SRC elisp
    (setq system-time-locale "C")
  #+END_SRC

** Start with better initial settings

   Although I do quite a bit of customization with my Emacs init code
   I like to start out by using the better init settings from the
   [[https://github.com/technomancy/better-defaults][better-defaults]] project.

   #+BEGIN_SRC elisp
     (use-package better-defaults
       :ensure t)
   #+END_SRC

   And now I will add a few default settings of my own. First, I like
   when emacs asks me if I want to do something but /y/ oder /n/ is enough
   as an answer!

   #+BEGIN_SRC elisp
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   Since I have been using emacs for a while now I don't need to see
   the start up message anymore. I can always go to it with =C-h C-a=.

   #+BEGIN_SRC elisp
     (setq-default inhibit-startup-message t)
   #+END_SRC

   When scrolling I like to scroll the screen and not my eyes. Yeah,
   yeah, I know there is =C-l=, but I don't want that...

   #+BEGIN_SRC elisp
     (setq-default scroll-preserve-screen-position 'keep)
   #+END_SRC

   Many times I need to reload a file but the =revert-buffer= function
   always asks me. And yes I am sure I want to revert the buffer!!!
   That is why I called the function in the first place. Since I am
   lazy I create a little wrapper that takes care of this problem:

   #+BEGIN_SRC elisp
     (defun revert-buffer-no-confirm ()
       "Function that reverts buffer without asking for confirmation"
       (interactive)
       (revert-buffer 'noconfirm t))

   #+END_SRC

** Tabs vs Spaces

   I have learned to distrust tabs in my source code, so let's make
   sure that we only have spaces. See [[http://ergoemacs.org/emacs/emacs_tabs_space_indentation_setup.html][this discussion]] for details.

   #+BEGIN_SRC elisp
     (setq-default indent-tabs-mode nil)
     (setq tab-width 2)
   #+END_SRC

   Make tab key do indent first then completion.

   #+BEGIN_SRC elisp
     (setq-default tab-always-indent 'complete)
   #+END_SRC

** TODO Encrypting Files

   This section includes the file encryption using pgp. Since I have
   no clue about it yet I will leave this for later.

* Display Settings

  I may not have been using Emacs for as long as Howard Abrams has,
  but I do appreciate a minimalist approach to its display as well. To
  clear up the user interface a little be the following settings do
  some of the essential stuff:

  #+BEGIN_SRC elisp
    (setq initial-scratch-message "") ;; Uh, I know what Scratch is for
    (setq visible-bell t)             ;; Get rid of the beeps

    (when (window-system)
      (tool-bar-mode 0)               ;; Toolbars were only cool with XEmacs
      (when (fboundp 'horizontal-scroll-bar-mode)
        (horizontal-scroll-bar-mode -1))
      (scroll-bar-mode -1))            ;; Scrollbars are waste screen estate
  #+END_SRC

** Mode Line

   Howard Abrams [[file:emacs-mode-line.org][mode-line code]] is a little more complex and deserved
   its own file.  To initialize and use it use the following code:

   #+BEGIN_SRC elisp
     (require 'init-mode-line)
   #+END_SRC

** Whitespace Mode

   You don't want this on all the time, but nice to turn it on every
   now and then:

   #+BEGIN_SRC elisp
     (use-package whitespace
       :bind ("C-c T w" . whitespace-mode)
       :init
       (setq whitespace-line-column nil
             whitespace-display-mappings '((space-mark 32 [183] [46])
                                           (newline-mark 10 [9166 10])
                                           (tab-mark 9 [9654 9] [92 9])))
       :config
       (set-face-attribute 'whitespace-space       nil :foreground "#666666" :background nil)
       (set-face-attribute 'whitespace-newline     nil :foreground "#666666" :background nil)
       (set-face-attribute 'whitespace-indentation nil :foreground "#666666" :background nil)
       :diminish whitespace-mode)
   #+END_SRC

** Fill Mode

   Automatically wrapping when you get to the end of a line (or the
   fill-region):

   #+BEGIN_SRC elisp
     (use-package fill
       :bind ("C-c T f" . auto-fill-mode)
       :init (add-hook 'org-mode-hook 'turn-on-auto-fill)
       :diminish auto-fill-mode)
   #+END_SRC

* Key Bindings

** Function Key Definitions

   Emacs has never seen a need for function keys, and I agree...for
   the most part. For things really /away from the flow/, they don't
   seem to bad. But what are those?

   - *F1* - Help? Isn't Control-H good enough?
   - *F2* - Special odd, little-used characters that I have to think
            about before remembering what its binding.
   - *F3* - Define a keyboard macro
   - *F4* - Replay a keyboard macro
   - *F5* - Use org-mode‚Äôs Mark Ring feature globally
   - *F6* - Open to temporary, changeable commands...
   - *F7* - Switch to another window ... Control goes the other way.
   - *F8* - Switch to buffer
   - *F9* - My extension (replacement?) for =C-c= for changing colors
     and other odd bindings that I actually don't use that often.

   #+BEGIN_SRC elisp
     (global-set-key (kbd "<f5>") 'org-mark-ring-push)
     (global-set-key (kbd "C-<f5>") 'org-mark-ring-goto)
     (global-set-key (kbd "<f7>") 'other-window)
     (global-set-key (kbd "C-<f7>") (lambda () (interactive) (other-window -1)))
   #+END_SRC

*** F2 and F9 Helpers

    The F9 prefix is scattered about my config files.

    #+BEGIN_SRC elisp
      (define-prefix-command 'personal-global-map)
      (global-set-key (kbd "<f9>") 'personal-global-map)
    #+END_SRC

    Unlike the *F9* bindings, all the *F2* key-bindings happen in a
    single [[file:emacs-f2.org][library file]]:

    #+BEGIN_SRC elisp
      (require 'init-f2)
    #+END_SRC

** Hydra Sequences

   I‚Äôm starting to appreciate the [[https://github.com/abo-abo/hydra][Hydra project]].

   #+BEGIN_SRC elisp
     (use-package hydra
       :ensure t
       :config
       (hydra-add-font-lock))
   #+END_SRC

   Easily manipulate the size of the windows using the arrow keys in a
   particular buffer window.

   #+BEGIN_SRC elisp
     (require 'windmove)

     (defun hydra-move-splitter-left (arg)
       "Move window splitter left."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'right))
           (shrink-window-horizontally arg)
         (enlarge-window-horizontally arg)))

     (defun hydra-move-splitter-right (arg)
       "Move window splitter right."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'right))
           (enlarge-window-horizontally arg)
         (shrink-window-horizontally arg)))

     (defun hydra-move-splitter-up (arg)
       "Move window splitter up."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'up))
           (enlarge-window arg)
         (shrink-window arg)))

     (defun hydra-move-splitter-down (arg)
       "Move window splitter down."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'up))
           (shrink-window arg)
         (enlarge-window arg)))

     (defhydra hydra-splitter (global-map "<f9> h")
       "splitter"
       ("<left>" hydra-move-splitter-left)
       ("<down>" hydra-move-splitter-down)
       ("<up>" hydra-move-splitter-up)
       ("<right>" hydra-move-splitter-right))
   #+END_SRC

   Other Hydra sequences are associated with the package they control.
** Displaying Command Sequences

   Many command sequences may be logical, but who can remember them
   all? While I used to use [[https://github.com/kai2nenobu/guide-key][guide-key]] to display the final function
   name, it isn't as nice as [[https://github.com/justbur/emacs-which-key][which-key]].

   #+BEGIN_SRC elisp
     (use-package which-key
       :ensure t
       :defer 10
       :diminish which-key-mode
       :config

       ;; Replacements for how KEY is replaced when which-key displays
       ;;   KEY ‚Üí FUNCTION
       ;; Eg: After "C-c", display "right ‚Üí winner-redo" as "‚ñ∂ ‚Üí winner-redo"
       (setq which-key-key-replacement-alist
             '(("<\\([[:alnum:]-]+\\)>" . "\\1")
               ("left"                  . "‚óÄ")
               ("right"                 . "‚ñ∂")
               ("up"                    . "‚ñ≤")
               ("down"                  . "‚ñº")
               ("delete"                . "DEL") ; delete key
               ("\\`DEL\\'"             . "BS") ; backspace key
               ("next"                  . "PgDn")
               ("prior"                 . "PgUp"))

             ;; List of "special" keys for which a KEY is displayed as just
             ;; K but with "inverted video" face... not sure I like this.
             which-key-special-keys '("RET" "DEL" ; delete key
                                      "ESC" "BS" ; backspace key
                                      "SPC" "TAB")

             ;; Replacements for how part or whole of FUNCTION is replaced:
             which-key-description-replacement-alist
             '(("Prefix Command" . "prefix")
               ("\\`calc-"       . "") ; Hide "calc-" prefixes when listing M-x calc keys
               ("/body\\'"       . "") ; Remove display the "/body" portion of hydra fn names
               ("\\`projectile-" . "ùìü/")
               ("\\`hydra-"      . "+ùêá/")
               ("\\`org-babel-"  . "ob/"))

             ;; Underlines commands to emphasize some functions:
             which-key-highlighted-command-list
             '(("\\`hydra-" . which-key-group-description-face)
               "\\(rectangle-\\)\\|\\(-rectangle\\)"
               "\\`org-"))

       ;; Change what string to display for a given *complete* key binding
       ;; Eg: After "C-x", display "8 ‚Üí +unicode" instead of "8 ‚Üí +prefix"
       (which-key-add-key-based-replacements
         "C-x 8"   "unicode"
         "C-c T"   "toggles-"
         "C-c p s" "projectile-search"
         "C-c p 4" "projectile-other-buffer-"
         "C-x a"   "abbrev/expand"
         "C-x r"   "rect/reg"
         "C-c /"   "engine-mode-map"
         "C-c C-v" "org-babel")

       (which-key-mode 1))
   #+END_SRC

** Highlighting and Narrowing

   I like the ability to highlight random text.

   - =M-s h .= :: highlight-symbol-at-point
   - =M-s h l= :: highlight-lines-matching-regexp
   - =M-s h p= :: highlight-phrase
   - =M-s h r= :: highlight-regexp
   - =M-s h u= :: unhighlight-regexp

   May get specific highlights automatically for certain files. We
   begin by highlighting lines in *.log files.

   #+BEGIN_SRC elisp
     (defun ms/highlite-logs ()
       "Highlight certain lines in specific files. Currently, only log files are supported."
       (interactive)
       (when (equal "log" (file-name-extension (buffer-file-name)))
             (hi-lock-mode 1)
             (highlight-lines-matching-regexp "ERROR:" 'hi-red-b)
             (highlight-lines-matching-regexp "NOTE:" 'hi-blue-b)))
   #+END_SRC

   The condition in this function that checks for the =log= extension,
   allows me to hook it to the loading of any file:

   #+BEGIN_SRC elisp :tangle no
     (add-hook 'find-file-hook 'ms/highlite-logs)
   #+END_SRC

   Turn on specific word groupings for specific occasions. We begin
   with highlighting keywords I use during note-taking sessions at
   the end of a sprint.

   #+BEGIN_SRC elisp
     (defun ms/sprint-retrospective-highlighting ()
       "Highlights the good, the bad and the improvements to make when taking notes."
       (interactive)
       (hi-lock-mode t)
       (highlight-lines-matching-regexp "^   [-*] " 'hi-black-b)
       (highlight-phrase "TODO:?" 'hi-black-b)
       (highlight-regexp "(?Good)?:?" 'hi-green-b)
       (highlight-regexp "(?Bad)?:?" 'hi-red-b)
       (highlight-regexp "Imp\\(rove\\)?:" 'hi-blue-b))
   #+END_SRC

   This works really well with other commands, including
   [[https://github.com/Bruce-Connor/fancy-narrow][fancy-narrow]], where I can visually high-light a section of a
   buffer. Great for code-reviews and other presentations.

   #+BEGIN_SRC elisp
     (use-package fancy-narrow
       :ensure t
       :config
       (defun ms/highlight-block ()
         "Highlights a 'block' in a buffer defined by the first blank
          line before and after the current cursor position. Uses the
          'fancy-narrow' mode to high-light the block."
         (interactive)
         (let (cur beg end)
           (setq cur (point))
           (setq end (or (re-search-forward  "^\s*$" nil t) (point-max)))
           (goto-char cur)
           (setq beg (or (re-search-backward "^\s*$" nil t) (point-min)))
           (fancy-narrow-to-region beg end)
           (goto-char cur)))

       (defun ms/highlight-section (num)
         "If some of the buffer is highlighted with the `fancy-narrow'
          mode, then un-highlight it by calling `fancy-widen'.

          If region is active, call `fancy-narrow-to-region'.

          If NUM is 0, highlight the current block (delimited by blank
          lines). If NUM is positive or negative, highlight that number
          of lines.  Otherwise, called `fancy-narrow-to-defun', to
          highlight current function."
         (interactive "p")
         (cond
          ((fancy-narrow-active-p)  (fancy-widen))
          ((region-active-p)        (fancy-narrow-to-region (region-beginning) (region-end)))
          ((= num 0)                (ms/highlight-block))
          ((= num 1)                (fancy-narrow-to-defun))
          (t                        (progn (ms/expand-region num)
                                           (fancy-narrow-to-region (region-beginning) (region-end))))))

       :bind ("C-M-+" . ms/highlight-section))
   #+END_SRC

   This nifty function from [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Endless Parenthesis]] is a nice replacement
   for many other narrowing keybindings that I use:

   #+BEGIN_SRC elisp
     (defun narrow-or-widen-dwim (p)
       "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
     Intelligently means: region, subtree, or defun, whichever applies
     first.

     With prefix P, don't widen, just narrow even if buffer is already
     narrowed."
       (interactive "P")
       (declare (interactive-only))
       (cond ((and (buffer-narrowed-p) (not p)) (widen))
             ((region-active-p)
              (narrow-to-region (region-beginning) (region-end)))
             ((derived-mode-p 'org-mode) (org-narrow-to-subtree))
             (t (narrow-to-defun))))

     (global-set-key (kbd "C-x n x") 'narrow-or-widen-dwim)
   #+END_SRC

** Jumping to Windows

  Set up [[https://github.com/abo-abo/ace-window][ace-window]] mode:

  #+BEGIN_SRC elisp
    (use-package ace-window
      :ensure t
      :init
        (setq aw-keys '(?a ?s ?d ?f ?j ?k ?l ?o))
        (global-set-key (kbd "C-x o") 'ace-window)
      :diminish ace-window-mode)
  #+END_SRC

** Selecting a Buffer
   I like =IDO= for switching buffers since I typically know what I'm after:

   #+BEGIN_SRC elisp
    (global-set-key (kbd "<f8>") 'ido-switch-buffer)
    (global-set-key (kbd "S-<f8>") 'ibuffer)
   #+END_SRC

   I like [[https://github.com/KMahoney/kpm-list][kpm-list]] a bit better than =ibuffer=, but I really don‚Äôt use
   either more than =ido-switch-buffer=. Still:

   #+BEGIN_SRC elisp
    (use-package kpm-list
      :ensure t
      :bind ("S-<f8>" . kpm-list)
            ("C-x C-b" . kpm-list))
   #+END_SRC

** Controlling Window Placement

   While [[http://www.emacswiki.org/emacs/WinnerMode][winner-mode]] is easy to keep the current window configuration
   /clean/, the [[https://github.com/tlh/workgroups.el][workgroups]] project has more features. However, due to
   existing bugs in that project, I've switched to [[https://github.com/pashinin/workgroups2][workgroups2]]:

   #+BEGIN_SRC elisp
     (use-package workgroups2
       :ensure t
       :init
       (setq wg-prefix-key (kbd "C-c w")
             wg-session-file "~/.emacs.d/workgroups"
             wg-mode-line-display-on nil
             ;; What to do on Emacs exit / workgroups-mode exit?
             wg-emacs-exit-save-behavior           nil      ; Options: 'save 'ask nil
             wg-workgroups-mode-exit-save-behavior 'save)
       (workgroups-mode 1))
   #+END_SRC

   Short answer for using it:

   - ~C-c a c~ to create and name a new /view/
   - Configure the screen as you like it
   - ~C-c a u~ to have that view as the base for that name
   - ~C-c a v~ to switch to a particular workgroup view.
   - ~C-c a C-s~ to save all workgroup views to the file.

** Better Jumping

   Mostly using the [[https://github.com/abo-abo/avy][avy]] project's [[help:avy-goto-word-1][avy-goto-word-1]] function, so I bind
   that to =C-c j=, but the recent update to include a timer feature,
   seems awful sweet:

   #+Begin_SRC elisp
     (use-package avy
       :ensure t
       :commands avy-goto-word-1 avy-goto-char-1 avy-goto-line avy-goto-char-timer
       :bind
       ("C-c j"   . avy-goto-word-1)
       ("A-j"     . avy-goto-word-1)    ; The Mac Command key
       ("s-j"     . avy-goto-word-1)    ; The Command key on Linux
       ("A-h"     . avy-goto-char-2)
       ("s-h"     . avy-goto-char-2)
       ("C-c k k" . avy-goto-char-timer)
       ("A-J"     . avy-goto-char-timer)    ; The Mac Command key
       ("s-J"     . avy-goto-char-timer)    ; The Command key on Linux
       ("C-c k j" . avy-goto-word-1)
       ("C-c k c" . avy-goto-char-1)
       ("C-c k l" . avy-goto-line)
       ("C-c k p" . avy-pop-mark)
       ("A-,"     . avy-pop-mark))
   #+END_SRC

   Other options (that require more of my memory), are bound
   to =C-c k=.

** Unfill Paragraph

   Unfilling a paragraph joins all the lines in a paragraph into a
   single line. Taken from [[http://www.emacswiki.org/UnfillParagraph][here]].

   #+BEGIN_SRC elisp
     (defun unfill-paragraph ()
       "Takes a multi-line paragraph and makes it into a single line of text."
       (interactive)
       (let ((fill-column (point-max)))
         (fill-paragraph nil)))

     ;; Handy key definition
     (define-key global-map "\M-Q" 'unfill-paragraph)
   #+END_SRC

** General behavior fixes

   There are a few subtle changes I'm making to Emacs and in case they
   grow out of proportion is start out with its

   #+BEGIN_SRC elisp
     (require 'init-fixes)
   #+END_SRC

** Multiple Cursors

   While I'm not sure how often I will use [[https://github.com/emacsmirror/multiple-cursors][multiple-cursors]] project,
   I'm going to try to remember it is there. It doesn't have any
   default keybindings, so I set up the suggested:

   #+BEGIN_SRC elisp
     (use-package multiple-cursors
       :ensure t
       :config
       (global-set-key
        (kbd "C-c C-.")
        (defhydra hydra-multiple-cursors ()
          "multiple-cursors"
          ("." mc/mark-all-dwim                   "all-dwim")
          ("C-." mc/mark-all-like-this-dwim       "all-like-dwim")
          ("n" mc/mark-next-like-this             "next")
          ("p" mc/mark-previous-like-this         "previous")
          ("a" mc/mark-all-like-this              "mark-all")
          ("N" mc/mark-next-symbol-like-this      "next-symbol")
          ("P" mc/mark-previous-symbol-like-this  "previous-symbol")
          ("A" mc/mark-all-symbols-like-this      "all-symbols")
          ("f" mc/mark-all-like-this-in-defun     "in-func")
          ("l" mc/edit-lines                      "all-lines")
          ("e" mc/edit-ends-of-lines              "end-lines"))))
   #+END_SRC

** Expand Region

   Wherever you are in a file, and whatever the type of file, you can
   slowly increase a region selection by logical segments by using
   Magnar's [[https://github.com/magnars/expand-region.el][expand-region]] project.

   However, the normal experience for =expand-region= is interactive,
   expected to be called repeatedly to expand and contract the regions
   based on syntax, and whatnot. Since I am seldom sure what I will
   select if I give this function a numeric prefix, I created a
   wrapper function that will (when given a number), just select the
   number of lines for the region. Select the current line with a 0
   argument. No argument (well, =lines= is given 1 with no argument),
   then it just calls =expand-region=:

   #+BEGIN_SRC elisp
     (use-package expand-region
       :ensure t
       :config
       (defun ha/expand-region (lines)
         "Prefix-oriented wrapper around Magnar's `er/expand-region'.

     Call with LINES equal to 1 (given no prefix), it expands the
     region as normal.  When LINES given a positive number, selects
     the current line and number of lines specified.  When LINES is a
     negative number, selects the current line and the previous lines
     specified.  Select the current line if the LINES prefix is zero."
         (interactive "p")
         (cond ((= lines 1)   (er/expand-region 1))
               ((< lines 0)   (ha/expand-previous-line-as-region lines))
               (t             (ha/expand-next-line-as-region (1+ lines)))))

       (defun ha/expand-next-line-as-region (lines)
         (message "lines = %d" lines)
         (beginning-of-line)
         (set-mark (point))
         (end-of-line lines))

       (defun ha/expand-previous-line-as-region (lines)
         (end-of-line)
         (set-mark (point))
         (beginning-of-line (1+ lines)))

       :bind ("C-=" . ha/expand-region))
   #+END_SRC

** Block Wrappers

   While the =M-(= binding to =insert-pair= is great, I often need to
   wrap with other characters:

   #+BEGIN_SRC elisp
     (global-set-key (kbd "M-[") 'insert-pair)
     (global-set-key (kbd "M-{") 'insert-pair)
     (global-set-key (kbd "M-<") 'insert-pair)
     (global-set-key (kbd "M-'") 'insert-pair)
     (global-set-key (kbd "M-`") 'insert-pair)
     (global-set-key (kbd "M-\"") 'insert-pair)
   #+END_SRC

   But [[https://github.com/rejeep/wrap-region.el][wrap-region]] is even more flexible. In most editors, selecting
   text and typing anything replaces the selected text (see the
   [[info:emacs#Using%20Region][delete-selection-mode]]), but in this case, we can do something
   different... like wrapping:

   #+BEGIN_SRC elisp
     (use-package wrap-region
       :ensure   t
       :config
       (wrap-region-global-mode t)
       (wrap-region-add-wrappers
        '(("(" ")")
          ("[" "]")
          ("{" "}")
          ("<" ">")
          ("'" "'")
          ("\"" "\"")
          ("‚Äò" "‚Äô"   "q")
          ("‚Äú" "‚Äù"   "Q")
          ("*" "*"   "b"   org-mode)                 ; bolden
          ("*" "*"   "*"   org-mode)                 ; bolden
          ("/" "/"   "i"   org-mode)                 ; italics
          ("/" "/"   "/"   org-mode)                 ; italics
          ("~" "~"   "c"   org-mode)                 ; code
          ("~" "~"   "~"   org-mode)                 ; code
          ("=" "="   "v"   org-mode)                 ; verbatim
          ("=" "="   "="   org-mode)                 ; verbatim
          ("_" "_"   "u" '(org-mode markdown-mode))  ; underline
          ("**" "**" "b"   markdown-mode)            ; bolden
          ("*" "*"   "i"   markdown-mode)            ; italics
          ("`" "`"   "c" '(markdown-mode ruby-mode)) ; code
          ("`" "'"   "c"   lisp-mode)                ; code
          ))
       :diminish wrap-region-mode)
   #+END_SRC

   But in order to wrap text in a more general way (with just about
   any textual string), we need something more. Especially with the
   =expand-region= command, wrapping a logical block of text with a
   beginning and ending string really makes sense.

   #+BEGIN_SRC elisp
     (defun surround (start end txt)
       "Wraps the specified region (or the current 'symbol / word'
     with some textual markers that this function requests from the
     user. Opening-type text, like parens and angle-brackets will
     insert the matching closing symbol.

     This function also supports some org-mode wrappers:

       - `#s` wraps the region in a source code block
       - `#e` wraps it in an example block
       - `#q` wraps it in an quote block"
       (interactive "r\nsEnter text to surround: " start end txt)

       ;; If the region is not active, we use the 'thing-at-point' function
       ;; to get a "symbol" (often a variable or a single word in text),
       ;; and use that as our region.

       (if (not (region-active-p))
           (let ((new-region (bounds-of-thing-at-point 'symbol)))
             (setq start (car new-region))
             (setq end (cdr new-region))))

       ;; We create a table of "odd balls" where the front and the end are
       ;; not the same string.
       (let* ((s-table '(("#e" . ("#+BEGIN_EXAMPLE\n" "\n#+END_EXAMPLE") )
                         ("#s" . ("#+BEGIN_SRC \n"    "\n#+END_SRC"))
                         ("#q" . ("#+BEGIN_QUOTE\n"   "\n#+END_QUOTE"))
                         ("#l" . ("#+BEGIN_LaTeX\n"   "\n#+END_LaTeX"))
                         ("<"  . ("<" ">"))
                         ("("  . ("(" ")"))
                         ("{"  . ("{" "}"))
                         ("["  . ("[" "]"))))    ; Why yes, we'll add more
              (s-pair (assoc-default txt s-table)))

         ;; If txt doesn't match a table entry, then the pair will just be
         ;; the text for both the front and the back...
         (unless s-pair
           (setq s-pair (list txt txt)))

         (save-excursion
           (narrow-to-region start end)
           (goto-char (point-min))
           (insert (car s-pair))
           (goto-char (point-max))
           (insert (cadr s-pair))
           (widen))))

     (global-set-key (kbd "C-+") 'surround)
   #+END_SRC

   To make it easier to call from other functions, let's wrap that
   wrapper:

   #+BEGIN_SRC elisp
     (defun surround-text (txt)
       (if (region-active-p)
           (surround (region-beginning) (region-end) txt)
         (surround nil nil txt)))
   #+END_SRC

   This function returns an interactive lambda expression, suitable
   for adding to a key-binding:

   #+BEGIN_SRC elisp
     (defun surround-text-with (surr-str)
       "Returns an interactive function that when called, will surround the region (or word) with the SURR-STR string."
       (lexical-let ((text surr-str))
         (lambda ()
           (interactive)
           (surround-text text))))
   #+END_SRC

* Loading and Finding Files
** Dired Options

   Between =M-!= and starting [[Eshell][Eshell]], comes =dired= (=C-x d=).

   #+BEGIN_SRC elisp
     (setq ls-lisp-use-insert-directory-program nil)
   #+END_SRC

   This enhancement to dired hides the ugly details until you hit
   '(' and shows the details with ')'. I also change the [...] to a
   simple asterisk.

   #+BEGIN_SRC elisp
     (use-package dired-details
       :ensure t
       :init   (setq dired-details-hidden-string "* ")
       :config (dired-details-install))
   #+END_SRC

   The ability to create a dired buffer based on searching for files
   in a directory tree with =find-name-dired= is fantastic. The
   [[http://www.masteringemacs.org/articles/2011/03/25/working-multiple-files-dired/][following magic]] optimizes this approach:

   #+BEGIN_SRC elisp
     (use-package find-dired
        :ensure t
        :init (setq find-ls-option '("-print0 | xargs -0 ls -od" . "-od")))
   #+END_SRC

   The [[http://pragmaticemacs.com/emacs/quickly-preview-images-and-other-files-with-peep-dired/][peep project]] allows you to preview files before loading them
   into a dedicated buffer:

   #+BEGIN_SRC elisp
     (use-package peep-dired
       :defer t ; don't access `dired-mode-map' until `peep-dired' is loaded
       :bind (:map dired-mode-map
                   ("P" . peep-dired)))
   #+END_SRC

   The [[http://www.masteringemacs.org/articles/2014/04/10/dired-shell-commands-find-xargs-replacement/][dired-x project]] seems useful:

   #+BEGIN_SRC elisp
     (require 'dired-x)
   #+END_SRC


   When collaborating with my colleagues I like to send them the link
   of a file of interest that is located on one of our network
   drives. Especially when using Windows not everyone maps their
   network drives to the same letter. Therefore, it is best to send
   the links as *Internet Links*. This will send the absolute path and
   takes care of any /whitespace/ incompatibilities.


   #+BEGIN_SRC elisp
     (use-package dired
       :config
       (defun ms/dired-copy-internet-path ()
         "This function allows a link to a file to be copied from
       within the dired mode as an internet path. This avoids common
       issues (e.g. whitespaces in the dir/filename) that would
       otherwise render the link useless.

       Behavior: The current absolute path to the file is pushed onto
       the kill ring with help of the 'dired-file-name-at-point'
       function.  Next, within a temporary buffer the link is formated
       by prepending 'file:' and replacing problematic characters such
       as whitespaces."
         (interactive)
         (kill-new (dired-file-name-at-point))
         (with-temp-buffer
           (insert (current-kill 0))
           (kill-new (concat "file:" (replace-regexp-in-string "\s" "\%20" (buffer-string)))))
         (message "%s => clipboard"  (current-kill 0)))
       (define-key dired-mode-map (kbd "W") 'ms/dired-copy-internet-path)
       )
   #+END_SRC

** IDO (Interactively DO Things)

   According to [[http://www.masteringemacs.org/articles/2010/10/10/introduction-to-ido-mode/][Mickey]], IDO is the greatest thing.

   #+BEGIN_SRC elisp
     (use-package ido
       :ensure t
       :init  (setq ido-enable-flex-matching t
                    ido-ignore-extensions t
                    ido-use-virtual-buffers t
                    ido-everywhere t)
       :config
       (ido-mode 1)
       (ido-everywhere 1)
       (add-to-list 'completion-ignored-extensions ".pyc"))
   #+END_SRC

   Add to IDO, the [[https://github.com/lewang/flx][FLX]] package:

   #+BEGIN_SRC elisp
     (use-package flx-ido
        :ensure t
        :init (setq ido-enable-flex-matching t
                    ido-use-faces nil)
        :config (flx-ido-mode 1))
   #+END_SRC

   According to [[https://gist.github.com/rkneufeld/5126926][Ryan Kneufeld]], we could make IDO work vertically,
   which is much easier to read. For this, I use [[https://github.com/gempesaw/ido-vertical-mode.el][ido-vertically]]:

   #+BEGIN_SRC elisp
     (use-package ido-vertical-mode
       :ensure t
       :init               ; I like up and down arrow keys:
       (setq ido-vertical-define-keys 'C-n-C-p-up-and-down)
       :config
       (ido-vertical-mode 1))
   #+END_SRC

*** IDO File Listing by Modified Time

    This sorts an IDO filelist by /mtime/ instead of alphabetically.

    #+BEGIN_SRC elisp
      (defun ido-sort-mtime ()
        "Reorder the IDO file list to sort from most recently modified."
        (setq ido-temp-list
              (sort ido-temp-list
                    (lambda (a b)
                      (time-less-p
                       (sixth (file-attributes (concat ido-current-directory b)))
                       (sixth (file-attributes (concat ido-current-directory a)))))))
        (ido-to-end  ;; move . files to end (again)
         (delq nil (mapcar
                    (lambda (x) (and (char-equal (string-to-char x) ?.) x))
                    ido-temp-list))))

      (add-hook 'ido-make-file-list-hook 'ido-sort-mtime)
      (add-hook 'ido-make-dir-list-hook 'ido-sort-mtime)
    #+END_SRC

*** Editing Root Files

    Once I used a =find-file-as-root= function (graciously borrowed from
    [[http://emacs-fu.blogspot.com/2013/03/editing-with-root-privileges-once-more.html][Emacs Fu]] and Howard Abrams), however, [[http://emacsredux.com/blog/2013/04/21/edit-files-as-root/][bbatsov]] offered a better idea to lend some
    /advice/ to =find-file=, so that non-writable files would be
    automatically /re-opened/ using the =sudo= feature of Tramp.

    The new version works with both local and remotely access files:

    #+BEGIN_SRC elisp
      (defadvice ido-find-file (after find-file-sudo activate)
        "Find file as root if necessary."
        (unless (and buffer-file-name
                     (file-writable-p buffer-file-name))
          (let* ((file-name (buffer-file-name))
                 (file-root (if (string-match "/ssh:\\([^:]+\\):\\(.*\\)" file-name)
                                (concat "/ssh:"  (match-string 1 file-name)
                                        "|sudo:" (match-string 1 file-name)
                                        ":"      (match-string 2 file-name))
                              (concat "/sudo:localhost:" file-name))))
            (find-alternate-file file-root))))
    #+END_SRC

    No special key-bindings, just load up a file, and if I can't write
    it, it will automatically ask me for my credentials, and away I go.

** SMEX

   Built using [[*IDO%20(Interactively%20DO%20Things)][IDO]] to do something similar but with =M-x= commands:

   #+BEGIN_SRC elisp
     (use-package smex
       :ensure t
       :init (smex-initialize)
       :bind ("M-x" . smex)
             ("M-X" . smex-major-mode-commands))
   #+END_SRC

** Helm

   Obviously, Helm would be helpful if I can learn all the bindings,
   so:

   #+BEGIN_SRC elisp
     (use-package helm
       :ensure t
       :init
       (use-package helm-config))   ;; Binds C-x c to the helm bidness.
   #+END_SRC

   Re-read [[http://tuhdo.github.io/helm-intro.html][this essay on Helm]].

** Recent File List

   According to [[http://www.emacswiki.org/emacs-es/RecentFiles][this article]], Emacs already has the recent file
   listing available, just not turned on.

   #+BEGIN_SRC elisp
     (use-package recentf
       :init
       (setq recentf-max-menu-items 25
             recentf-auto-cleanup 'never
             recentf-keep '(file-remote-p file-readable-p))
       (recentf-mode 1)
       (delete-file "~/.emacs.d/ido.last")
       :bind ("C-c f f" . recentf-open-files))
   #+END_SRC

   We do not want to stat all the files when Emacs starts up because
   files read by Tramp will slow down the start time.

** Backup Settings

   This setting moves all backup files to a central location.
   Got it from [[http://whattheemacsd.com/init.el-02.html][this page]].

   #+BEGIN_SRC elisp
     (setq backup-directory-alist
           `(("." . ,(expand-file-name
                      (ms/emacs-subdirectory "backups")))))
   #+END_SRC

   Make backups of files, even when they're in version control

   #+BEGIN_SRC elisp
     (setq vc-make-backup-files t)
   #+END_SRC

   And let‚Äôs make sure our files are saved if we wander off and
   defocus the Emacs application:

   #+BEGIN_SRC elisp
     (defun save-all ()
       "Saves all dirty buffers without asking for confirmation."
       (interactive)
       (save-some-buffers t))

     (add-hook 'focus-out-hook 'save-all)
   #+END_SRC

* Word Smithing
** Auto Insertion

   Just beginning to get a collection of templates to automatically
   insert if a blank file is loaded.

   #+BEGIN_SRC elisp
     (use-package autoinsert
       :init
       (setq auto-insert-directory (ms/emacs-subdirectory "templates/"))
       ;; Don't want to be prompted before insertion:
       (setq auto-insert-query nil)

       (add-hook 'find-file-hook 'auto-insert)
       (auto-insert-mode 1))
   #+END_SRC

   Add a =:config= section to configure static insertion, and add:

   #+BEGIN_SRC elisp :tangle no
     (define-auto-insert "\\.html?$" "default-html.html")
   #+END_SRC

   However, auto insertion requires entering data for particular fields,
   and for that Yasnippet is better, so in this case, we combine them:

   #+BEGIN_SRC elisp
     (defun ms/autoinsert-yas-expand()
       "Replace text in yasnippet template."
       (yas-expand-snippet (buffer-string) (point-min) (point-max)))
   #+END_SRC

   Now bind many of the templates for auto-insert and field expansion:

   #+BEGIN_SRC elisp
     (use-package autoinsert
       :config
       (define-auto-insert "\\.el$" ["default-lisp.el" ms/autoinsert-yas-expand])
       (define-auto-insert "\\.sh$" ["default-sh.sh" ms/autoinsert-yas-expand])
       (define-auto-insert "/bin/"  ["default-sh.sh" ms/autoinsert-yas-expand])
       (define-auto-insert "\\.html?$" ["default-html.html" ms/autoinsert-yas-expand]))
   #+END_SRC

** Auto Complete

   Using [[http://company-mode.github.io/][company-mode]] for all my auto completion needs.

   Like [[https://github.com/vspinu/company-math][this idea]] of being able to easily insert math
   symbols based on LaTeX keywords. Start typing a backslash.

   #+BEGIN_SRC elisp
     (use-package company
       :ensure t
       :init
       (add-hook 'after-init-hook 'global-company-mode)
       :config
       (add-to-list 'company-backends 'company-math-symbols-unicode)
       :diminish company-mode)
   #+END_SRC

   Take advantage of idle time by displaying some documentation
   using [[https://www.github.com/expez/company-quickhelp][company-quickhelp]] project.

   #+BEGIN_SRC elisp
     (use-package company-quickhelp
       :ensure t
       :config
       (company-quickhelp-mode 1))
   #+END_SRC

   This also requires [[https://github.com/pitkali/pos-tip/blob/master/pos-tip.el][pos-tip]].

** Yasnippets

   The [[https://github.com/capitaomorte/yasnippet][yasnippet project]] allows me to create snippets of code that
   can be brought into a file, based on the language.

   #+BEGIN_SRC elisp
     (use-package yasnippet
       :ensure t
       :init
       (yas-global-mode 1)
       :config
       (add-to-list 'yas-snippet-dirs (ms/emacs-subdirectory "snippets")))
   #+END_SRC

   *Note:* the =snippets= directory contains directories for each
   mode, e.g.  =clojure-mode= and =org-mode=.

** Spelling Correction with Abbreviation Mode

   According to [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][this discussion]], we can correct a misspelled word
   with =C-x C-i= and it will use the abbreviation mode to
   automatically correct that word...as long as you misspell it the
   same way each time.

   #+BEGIN_SRC elisp
     (defun ms/ispell-word-then-abbrev (p)
       "Call `ispell-word'. Then create an abbrev for the correction made.
     With prefix P, create local abbrev. Otherwise it will be global."
       (interactive "P")
       (let ((bef (downcase (or (thing-at-point 'word) ""))) aft)
         (call-interactively 'ispell-word)
         (setq aft (downcase (or (thing-at-point 'word) "")))
         (unless (string= aft bef)
           (message "\"%s\" now expands to \"%s\" %sally"
                    bef aft (if p "loc" "glob"))
           (define-abbrev
             (if p global-abbrev-table local-abbrev-table)
             bef aft))))

     (global-set-key (kbd "C-x C-i") 'ms/ispell-word-then-abbrev)
   #+END_SRC

   Need to turn on the mode, but not necessarily show it:

   #+BEGIN_SRC elisp
     (use-package abbrev
       :bind ("C-c T a" . abbrev-mode)
       :init (setq save-abbrevs t)
             (setq-default abbrev-mode t)
       :diminish abbrev-mode)
   #+END_SRC

** Spell Checking

   I like spell checking with [[http://www.emacswiki.org/emacs/FlySpell][FlySpell]], which uses the built-in
   spell-check settings of [[https://www.gnu.org/software/ispell/][ispell]].

   The [[http://aspell.net][ASpell]] project is better supported than ISpell.

   #+BEGIN_SRC sh :tangle no
     brew install aspell
   #+END_SRC

   I have taken my spell checking setting from [[http://blog.binchen.org/posts/what-s-the-best-spell-check-set-up-in-emacs.html][here]]. We will want to
   start flyspell for all text modes (but not for log files):

   #+BEGIN_SRC elisp
     (use-package flyspell
       :ensure t
       :diminish flyspell-mode
       :init
       (add-hook 'prog-mode-hook 'flyspell-prog-mode)

       (dolist (hook '(text-mode-hook org-mode-hook latex-mode-hook))
         (add-hook hook (lambda () (flyspell-mode 1))))

       (dolist (hook '(change-log-mode-hook log-edit-mode-hook org-agenda-mode-hook))
         (add-hook hook (lambda () (flyspell-mode -1))))

       )
   #+END_SRC

   To take Camel words into account we need a function that can
   detect the extra ispell arguments:

   #+BEGIN_SRC elisp
     (defun flyspell-detect-ispell-args (&optional run-together)
       "if RUN-TOGETHER is true, spell check the CamelCase words."
       (let (args)
         (cond
          ((string-match  "aspell$" ispell-program-name)
           ;; Force the English dictionary for aspell
           ;; Support Camel Case spelling check (tested with aspell 0.6)
           (setq args (list "--sug-mode=ultra" "--lang=en_US"))
           (if run-together
               (setq args (append args '("--run-together" "--run-together-limit=5" "--run-together-min=2")))))
          ((string-match "hunspell$" ispell-program-name)
           ;; Force the English dictionary for hunspell
           (setq args "-d en_US")))
         args))
   #+END_SRC

   Next we make aspell or hunspell our dictionary depending on which
   one is present on our system. I put Aspell as my first choice:

   #+BEGIN_SRC elisp
     (cond
      ((executable-find "aspell")
       ;; you may also need `ispell-extra-args'
       (setq ispell-program-name "aspell"))
      ((executable-find "hunspell")
       (setq ispell-program-name "hunspell")

       ;; Please note that `ispell-local-dictionary` itself will be passed to hunspell cli with "-d"
       ;; it's also used as the key to lookup ispell-local-dictionary-alist
       ;; if we use different dictionary
       (setq ispell-local-dictionary "en_US")
       (setq ispell-local-dictionary-alist
             '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8))))
      (t (setq ispell-program-name nil)))
   #+END_SRC

   Next we do the detecting of the extra arguments passed by flyspell:

   #+BEGIN_SRC elisp
     ;; ispell-cmd-args is useless, it's the list of *extra* arguments we will append to the ispell process when "ispell-word" is called.
     ;; ispell-extra-args is the command arguments which will *always* be used when start ispell process
     ;; Please note when you use hunspell, ispell-extra-args will NOT be used.
     ;; Hack ispell-local-dictionary-alist instead.
     (setq-default ispell-extra-args (flyspell-detect-ispell-args t))
     ;; (setq ispell-cmd-args (flyspell-detect-ispell-args))
     (defadvice ispell-word (around my-ispell-word activate)
       (let ((old-ispell-extra-args ispell-extra-args))
         (ispell-kill-ispell t)
         (setq ispell-extra-args (flyspell-detect-ispell-args))
         ad-do-it
         (setq ispell-extra-args old-ispell-extra-args)
         (ispell-kill-ispell t)
         ))
   #+END_SRC

   We are almost done. But before we reduce the suggestions offered by
   aspell by taking camel words into account and hook this to flyspell
   by giving some well overdue advise:

   #+BEGIN_SRC elisp
     (defadvice flyspell-auto-correct-word (around my-flyspell-auto-correct-word activate)
       (let ((old-ispell-extra-args ispell-extra-args))
         (ispell-kill-ispell t)
         ;; use emacs original arguments
         (setq ispell-extra-args (flyspell-detect-ispell-args))
         ad-do-it
         ;; restore our own ispell arguments
         (setq ispell-extra-args old-ispell-extra-args)
         (ispell-kill-ispell t)
         ))
   #+END_SRC

   At last we don't want the camel word detection when we run the
   spell checking in text mode:

   #+BEGIN_SRC elisp
     (defun text-mode-hook-setup ()
       ;; Turn off RUN-TOGETHER option when spell check text-mode
       (setq-local ispell-extra-args (flyspell-detect-ispell-args)))
     (add-hook 'text-mode-hook 'text-mode-hook-setup)
   #+END_SRC

   ASpell automatically configures a personal dictionary
   at =~/.aspell.en.pws=, so no need to configure that.

   Sometimes I would like to write some stuff in another language as
   well. For me that usually happens to be German. To change the
   dictionary, which I assume will not happen too many times, I have
   created the following sequence:

   #+BEGIN_SRC elisp
     (define-sequence 'dictionary-select-map "<f9> d" 'ispell-change-dictionary
       (list (list "e" "american")
             (list "a" "american")
             (list "d" "german")
             (list "g" "german")))
   #+END_SRC

* Miscellaneous Settings
** Line Numbers

   Turn =linum-mode= on/off with =Super-K=.  However, I
   turn this on automatically for programming modes.

   #+BEGIN_SRC elisp
     (use-package linum
       :init
       (add-hook 'prog-mode-hook 'linum-mode)
       (add-hook 'linum-mode-hook (lambda () (set-face-attribute 'linum nil :height 75)))

       :config
       (defun linum-fringe-toggle ()
         "Toggles the line numbers as well as the fringe."    (interactive)
         (cond (linum-mode (fringe-mode '(0 . 0))
                           (linum-mode -1))
               (t          (fringe-mode '(8 . 0))
                           (linum-mode 1))))

       :bind (("A-C-k"   . linum-mode)
              ("s-C-k"   . linum-mode)
              ("A-C-M-k" . linum-fringe-toggle)
              ("s-C-M-k" . linum-fringe-toggle)))
   #+END_SRC

   *Note:* make the line numbers a fixed size, then increasing or
   decreasing the font size doesn't truncate the numbers.

   The [[https://github.com/coldnew/linum-relative][linum-relative]] mode allows one to see the /destination/ line as a
   relative distance (like one 9 lines lower), and then =C-9 C-n= can
   quickly pop to it.

   #+BEGIN_SRC elisp
     (use-package linum-relative
       :ensure t
       :config
       (defun linum-new-mode ()
         "If line numbers aren't displayed, then display them.
          Otherwise, toggle between absolute and relative numbers."
         (interactive)
         (if linum-mode
             (linum-relative-toggle)
           (linum-new-mode 1)))

       :bind ("A-k" . linum-new-mode)
             ("s-k" . linum-new-mode))   ;; For Linux
   #+END_SRC

   But since the =SUPER= key on my windows machine usually does
   something windows related I added the following sequence as a
   backup plan:

   #+BEGIN_SRC elisp
     (define-sequence 'linum-select-map "<f9> l" 'funcall
       (list (list "l" 'linum-new-mode)
             (list "o" 'linum-fringe-toggle)))
   #+END_SRC

** Better Bookmarks

   For me, bookmarks serve two functions. First, as a way to jump
   back to interesting places by name (and annotate those places), and
   second, as form of /bread crumbs/ while I'm toiling around a large
   codebase.

   For normal bookmarks, I'd rather use Helm:
   #+BEGIN_SRC elisp
     (use-package bookmark
       :init (setq bookmark-save-flag 1)
       :config
       (defun ha/add-bookmark (name)
         (interactive
          (list (let* ((filename  (file-name-base (buffer-file-name)))
                       (func-name (which-function))
                       (initial   (format "%s:%s " filename func-name)))
                  (read-string "Bookmark: " initial))))
         (bookmark-set name))
       :bind  (("C-c b m" . ha/add-bookmark)
               ("C-x r m" . ha/add-bookmark)
               ("C-x r b" . helm-bookmarks)))
   #+END_SRC

*** Visual Bookmarks... Breadcrumbs

    For dropping visual breadcrumbs throughout a single file or
    multiple files, we use the [[https://github.com/joodland/bm][BM package]].

    #+BEGIN_SRC elisp
      (use-package bm
        :ensure t
        :init
        (setq bm-highlight-style 'bm-highlight-only-fringe
              bm-cycle-all-buffers t)
        :config
        ;; Make a more bookmarky symbol for a 'mark':
        (define-fringe-bitmap 'bm-marker-left [254 254 254 254 254 238 198 130] 8 8 'center)
        (let ((fringe-backgd (face-background 'fringe)))
          (set-face-attribute 'bm-fringe-face nil
                              :foreground "green" :background fringe-backgd))

        (defun bm-bookmark-defun ()
          "Drops a temporary breadcrumb/bookmark at the beginning of the current defun."
          (interactive)
          (save-excursion
            (beginning-of-defun)
            (bm-toggle)))

        :bind (("C-<f5>" . bm-toggle)
               ("<f5>"   . bm-next)
               ("M-<f5>" . bm-previous)
               ("C-c b s" . bm-show)
               ("C-c b r" . bm-bookmark-regexp)
               ("C-c b f" . bm-bookmark-defun)
               ("C-c b A" . bm-bookmark-annotate)
               ("C-c b a" . bm-bookmark-show-annotation)
               ("<left-margin> <mouse-1>" . bm-toggle-mouse)
               ("<left-fringe> <mouse-1>" . bm-toggle-mouse)))
    #+END_SRC

    - C-F5 :: bm-toggle to drop a mark or remove it
    - F5 :: bm-next to go to the next mark
    - M-F5 :: bm-previous to go to the previous mark

    - C-c b s :: bm-show brings up a buffer with all the little marks
         and the contents their line (see =bm-show-all= for all buffers)
    - C-c b r :: bm-bookmark-regexp to create a bunch of bookmarks
    - C-c b f :: bm-bookmark-function to bookmark the start of the function
    - C-c b A :: bm-bookmark-annotate Annotate the mark
    - C-c b a ::  Show the annotation (if any of the mark) ... would be
         nice if this could be automatically displayed.

    The biggest question is if I want =bm-previous= to go to the previous
    logical mark in the file or last mark that was set... perhaps we
    do both with different keys?

** Smart Comments

   The [[https://github.com/paldepind/smart-comment][smart-comment]] project has the nice feature of commenting a line
   without being at the beginning of the line (default comment in the
   middle of the line is to split it).

   #+BEGIN_SRC elisp
     (use-package smart-comment
       :ensure t
       :bind ("M-;" . smart-comment))
   #+END_SRC

   Also has the ability (with the =C-u= prefix) to mark comments as
   things to be deleted.

** Smart Scan

   Use the =M-n= to search the buffer for the word the cursor is
   currently pointing. =M-p= to go backwards. See [[http://www.masteringemacs.org/articles/2011/01/14/effective-editing-movement/][this essay]] for
   details.

   #+BEGIN_SRC elisp :tangle no
     (use-package smartscan
       :ensure t
       :bind (("M-n" . smartscan-symbol-go-forward)
              ("M-p" . smartscan-symbol-go-backward)))

     ;;; (require 'smartscan)
   #+END_SRC

** Strip Whitespace on Save

   When I save, I want to always, and I do mean always strip all
   trailing whitespace from the file.

   #+BEGIN_SRC elisp
     (add-hook 'before-save-hook 'delete-trailing-whitespace)
   #+END_SRC

** Save File Position

   Save the point position for every file, and restore it when that
   file is reloaded.

   #+BEGIN_SRC elisp
     (require 'saveplace)
     (setq-default save-place t)
     (setq save-place-forget-unreadable-files t)
     (setq save-place-skip-check-regexp "\\`/\\(?:cdrom\\|floppy\\|mnt\\|/[0-9]\\|\\(?:[^@/:]*@\\)?[^@/:]*[^@/:.]:\\)")
   #+END_SRC

** Better Searching and Visual Regular Expressions

   Searching is quite good in Emacs. Let's add a few extra keys:

   #+BEGIN_SRC elisp
     (bind-keys :map isearch-mode-map
                ("<left>"  . isearch-repeat-backward)
                ("<right>" . isearch-repeat-forward)
                ("<up>"    . isearch-ring-retreat)
                ("<down>"  . isearch-ring-advance))
   #+END_SRC

   Easier replacement of my [[http://www.masteringemacs.org/articles/2011/01/14/effective-editing-movement/][Smart Scan]] for searching forward/backward
   for the current word. This is now bound to =M-s .= (in Emacs 24.4),
   but I then have to hit =C-s= or =C-r= ... nicer to use the period/comma.

   The [[https://github.com/benma/visual-regexp.el][Visual Regular Expressions]] project highlights the matches
   while you try to remember the differences between Perl's regular
   expressions and Emacs'...

   Begin with =C-c r= then type the regexp. To see the highlighted
   matches, type =C-c a= before you hit 'Return' to accept it.

   #+BEGIN_SRC elisp
     (use-package visual-regexp
       :ensure t
       :init
       (use-package visual-regexp-steroids :ensure t)

       :bind (("C-c r" . vr/replace)
              ("C-c q" . vr/query-replace))

       ;; if you use multiple-cursors, this is for you:
       :config (use-package  multiple-cursors
                 :bind ("C-c m" . vr/mc-mark)))
   #+END_SRC

** Hungry Delete

   The Hungry Delete project is a [[http://endlessparentheses.com//hungry-delete-mode.html][free feature]], where deleting any
   space, deletes ALL spaces.

   This is already built into Emacs with the following:
   - =M-\= :: Removes all spaces
   - =M-SPC= :: Removes extra spaces, leaving just one
   - =M-^= :: Joins current line with previous line (doesn't matter
        where the point is on the line)
   - =M-- M-1 M-SPC= :: Joins next line to this one (if point at end
        of line) separated by a space ... quite the chording, eh?

** Table and Column Alignment

   While I shouldn't, I like to line up comma-separated columns (and
   colon-delimited hashes), and since I can never type the regular
   expression on the first time, I wrapped it up in a callable
   function.

   #+BEGIN_SRC elisp
     (defun align-comma (start end c)
       "Repeat alignment with a character padded with spaces for
     comma-separated columns."
       (interactive "r\nsAlign character: ")
       (align-regexp start end
                     (concat c "\\(\\s-*\\)") 1 1 t))
   #+END_SRC

** Calendar Tweeks

   I like the Emacs calendar but I would like to see the week numbers
   as well. Especially when at work this is useful. I found [[http://stackoverflow.com/questions/21364948/how-to-align-the-calendar-with-week-number-as-the-intermonth-text][these]]
   simple modifications that do the trick quite nicely. This configuration also switches the week starting day of the
   calender from Sunday to Monday.

   #+BEGIN_SRC elisp
     (setq calendar-week-start-day 1)

     (setq calendar-intermonth-text
           '(propertize
             (format "%2d"
                     (car
                      (calendar-iso-from-absolute
                       (calendar-absolute-from-gregorian (list month day year)))))
             'font-lock-face 'font-lock-warning-face))

     (setq calendar-intermonth-header
           (propertize "Wk"                  ; or e.g. "KW" in Germany
                       'font-lock-face 'font-lock-keyword-face))
   #+END_SRC

   In addition, I don't like how there is a buffer left whenever I
   close the calendar. To fix this I overwrite the =q= (quit) key
   locally for the calendar buffer:

   #+BEGIN_SRC elisp
     (defun ms/quit-calendar ()
       "This function ensures that the window where the calendar used to be after pressing 'q' is deleted as well"
       (local-set-key (kbd "q") 'delete-window))

     (add-hook 'calendar-mode-hook 'ms/quit-calendar)
   #+END_SRC

* Programming Languages

** General Language Support

   Many programming language environments can benefit from this section.

*** ElDoc

    I like ElDoc support (when I can get it), but not needed in the
    mode line:

    #+BEGIN_SRC elisp
      (use-package eldoc
        :diminish eldoc-mode)
    #+END_SRC

*** Code Block Folding

    The [[info:emacs#Hideshow][Hide Show Minor]] mode allows us to /fold/ all functions
    (hidden), showing only the header lines. We need to turn on the
    mode, so wrappers are in order:

    #+BEGIN_SRC elisp
      (defun ms/hs-show-all ()
        (interactive)
        (hs-minor-mode 1)
        (hs-show-all))

      (defun ms/hs-hide-all ()
        (interactive)
        (hs-minor-mode 1)
        (hs-hide-all))

      (defun ms/hs-toggle-hiding ()
        (interactive)
        (hs-minor-mode 1)
        (hs-toggle-hiding))
    #+END_SRC

    Seems that =C-c @= is too obnoxious to use, so I'll put my
    favorite on the =C-c h= prefix:

    #+BEGIN_SRC elisp
      (use-package hs-minor-mode
        :bind
        ("C-c T h" . hs-minor-mode)
        ("C-c h a" . ms/hs-hide-all)
        ("C-c h s" . ms/hs-show-all)
        ("C-c h h" . ms/hs-toggle-hiding))
    #+END_SRC

    See the [[http://www.emacswiki.org/emacs/HideShow][online resources]].

*** Aggressive Auto Indention

    Automatically indent without use of the tab found in [[http://endlessparentheses.com/permanent-auto-indentation.html][this article]],
    and seems to be quite helpful for many types of programming
    languages.

    To begin, we create a function that can indent a function by
    calling =indent-region= on the beginning and ending points of a
    function.

    #+BEGIN_SRC elisp
      (defun indent-defun ()
        "Indent current defun.
      Do nothing if mark is active (to avoid deactivaing it), or if
      buffer is not modified (to avoid creating accidental
      modifications)."
        (interactive)
        (unless (or (region-active-p)
                    buffer-read-only
                    (null (buffer-modified-p)))
          (let ((l (save-excursion (beginning-of-defun 1) (point)))
                (r (save-excursion (end-of-defun 1) (point))))
            (cl-letf (((symbol-function 'message) #'ignore))
              (indent-region l r)))))
    #+END_SRC

    Next, create a hook that will call the =indent-defun= with every
    command call:

    #+BEGIN_SRC elisp
      (defun activate-aggressive-indent ()
        "Locally add `ha/indent-defun' to `post-command-hook'."
        (add-hook 'post-command-hook
                  'indent-defun nil 'local))
    #+END_SRC

** Shell Scripts

   Files in my =bin= directory (but /only/ if it doesn't have any
   other extension), should start in =sh-mode=:

   #+BEGIN_SRC elisp
     (add-to-list 'auto-mode-alist '("/bin/" . sh-mode))
   #+END_SRC

** Emacs Lisp

   Sure, everything here is in Emacs Lisp, but this section helps me
   write more of that... like making snazzy symbols and colorizing the
   variables.

   The [[https://github.com/ankurdave/color-identifiers-mode][color-identifiers]] project (unlike [[https://github.com/Fanael/rainbow-identifiers][others]]), downplay the
   keywords, and increase the colorizing of the variables.

   #+BEGIN_SRC elisp
     (use-package color-identifiers-mode
       :ensure t
       :init
         (add-hook 'emacs-lisp-mode-hook 'color-identifiers-mode)
       :diminish color-identifiers-mode)
   #+END_SRC

   The only real snazzy symbol that I like is replacing the =lambda=
   with Œª:

   #+BEGIN_SRC elisp
     (use-package lisp-mode
       :init
       (defconst lisp--prettify-symbols-alist
         '(("lambda"  . ?Œª)
           ("."       . ?‚Ä¢)))
       :config
       (add-hook 'emacs-lisp-mode-hook 'global-prettify-symbols-mode)
       (add-hook 'emacs-lisp-mode-hook 'activate-aggressive-indent))
   #+END_SRC

*** Paredit

    One of the cooler features of Emacs is the [[http://emacswiki.org/emacs/ParEdit][ParEdit mode]] which
    keeps all parenthesis balanced in Lisp-oriented languages.
    See this [[http://www.emacswiki.org/emacs/PareditCheatsheet][cheatsheet]].

    #+BEGIN_SRC elisp
      (use-package paredit
        :ensure t
        :diminish paredit-mode
        :init
          (add-hook 'emacs-lisp-mode-hook 'paredit-mode))
    #+END_SRC

*** Colored Variables

    Color each variable, and downplay standard key words:

    #+BEGIN_SRC elisp
      (use-package color-identifiers-mode
        :ensure t
        :init
        (add-hook 'emacs-lisp-mode-hook 'color-identifiers-mode))
    #+END_SRC

*** Nicer Paren Matching

    The reverse mode of the default parenthesis matching doesn‚Äôt match
    as well, so [[http://www.emacswiki.org/emacs/ShowParenMode][this code]] just makes it bold and more obvious:

    #+BEGIN_SRC elisp
      (use-package paren
        :init
        (set-face-background 'show-paren-match (face-background 'default))
        (set-face-foreground 'show-paren-match "#afa")
        (set-face-attribute  'show-paren-match nil :weight 'black)
        (set-face-background 'show-paren-mismatch (face-background 'default))
        (set-face-foreground 'show-paren-mismatch "#c66")
        (set-face-attribute  'show-paren-mismatch nil :weight 'black))
    #+END_SRC

    While we are at it, let's dim the parens:

    #+BEGIN_SRC elisp
      (use-package paren-face
        :ensure t
        :init
        (global-paren-face-mode))
    #+END_SRC

*** Insert Comment of Eval

    While writing and documenting Emacs Lisp code, it would be helpful
    to insert the results of evaluation of an s-expression directly
    into the code as a comment:

    #+BEGIN_SRC elisp
      (use-package lisp-mode
        :config (defun eval-and-comment-output ()
                  "Add the output of the sexp as a comment after the sexp"
                  (interactive)
                  (save-excursion
                    (end-of-line)
                    (condition-case nil
                        (princ (concat " ; -> " (pp-to-string (eval (preceding-sexp))))
                               (current-buffer))
                      (error (message "Invalid expression")))))

        :bind ("C-x e" . eval-and-comment-output))
    #+END_SRC

** Python

   See [[file:emacs-python.org][emacs-python.el]] for details on working with Python.
   Not sure if I should just load it directly, like:

   #+BEGIN_SRC elisp
     (require 'init-python)
   #+END_SRC

** R

   The R programming language is great for statistical analysis. To
   get this to work we need to install R.  With my Ubuntu OS all it
   takes is the following command:

   #+BEGIN_SRC sh
     sudo apt-get install r-base
   #+END_SRC

   With windows it is a little more involved but the installation
   files can be downloaded [[https://cran.r-project.org/bin/windows/base/][here]].

   In addition to installing R we need to install [[http://ess.r-project.org/index.php?Section=download][ESS]] the Emacs speaks
   statistic environment. Again, on Ubuntu all it takes is:

   #+BEGIN_SRC sh
     sudo apt-get install ess
   #+END_SRC

   And on windows you can download it from the [[http://ess.r-project.org/index.php?Section=download][ESS download]] page. For
   the installation procedure you best check the [[http://ess.r-project.org/Manual/ess.html#Manual][manual]]. And since
   loading the ess mode is a little different depending on the
   operating system I wrap the different load scenarios in a
   conditional statement:

   I found some nifty initialization settings for the ESS package [[http://gongzhitaao.org/dotemacs/][Gong
   Zhitaao's]] webpage:

   #+BEGIN_SRC elisp
     (use-package ess-site
       :config

       (setq ess-R-font-lock-keywords
             '((ess-R-fl-keyword:modifiers . t)
               (ess-R-fl-keyword:fun-defs . t)
               (ess-R-fl-keyword:keywords . t)
               (ess-R-fl-keyword:assign-ops . t)
               (ess-R-fl-keyword:constants . t)
               (ess-fl-keyword:fun-calls)
               (ess-fl-keyword:numbers)
               (ess-fl-keyword:operators)
               (ess-fl-keyword:delimiters)
               (ess-fl-keyword:=)
               (ess-R-fl-keyword:F&T . t)
               (ess-R-fl-keyword:%op% . t)))

       (setq inferior-R-font-lock-keywords
             '((ess-S-fl-keyword:prompt . t)
               (ess-R-fl-keyword:messages . t)
               (ess-R-fl-keyword:modifiers . t)
               (ess-R-fl-keyword:fun-defs . t)
               (ess-R-fl-keyword:keywords . t)
               (ess-R-fl-keyword:assign-ops . t)
               (ess-R-fl-keyword:constants . t)
               (ess-fl-keyword:matrix-labels . t)
               (ess-fl-keyword:fun-calls)
               (ess-fl-keyword:numbers)
               (ess-fl-keyword:operators)
               (ess-fl-keyword:delimiters)
               (ess-fl-keyword:=)
               (ess-R-fl-keyword:F&T . t)))

       (defun my-ess-init ()
         "Init my ess mode."
         (setq ess-help-own-frame 'one)
         (setq ess-tab-complete-in-script t))
         ;;(setq ess-first-tab-never-complete
           ;;    'symbol-or-paren-or-punct))

       (add-hook 'ess-mode-hook #'my-ess-init))
       ;;(add-hook 'inferior-ess-mode-hook #'turn-on-smartparens-mode))
   #+END_SRC

* Org-Mode

  See [[file:emacs-org.org][emacs-org-mode.el]] for details on my [[http://www.orgmode][Org-Mode]] settings.

  #+BEGIN_SRC elisp
    (require 'init-org-mode)
  #+END_SRC

* Tools
** Git

   I like [[https://github.com/syohex/emacs-git-gutter-fringe][git-gutter-fringe]]:

   #+BEGIN_SRC elisp
     (use-package git-gutter-fringe
       :defer t
       :ensure t
       :diminish git-gutter-mode
       :init (git-gutter-mode 1))
   #+END_SRC

   I want to have special mode for Git's =configuration= file:

   #+BEGIN_SRC elisp
     (use-package gitconfig-mode
       :ensure t)

     (use-package gitignore-mode
       :ensure t)
   #+END_SRC

   What about being able to see the [[https://github.com/voins/mo-git-blame][Git blame]] in a buffer?

   #+BEGIN_SRC elisp
     (use-package mo-git-blame
        :ensure t)
   #+END_SRC

   Run =mo-git-blame-current= to see the goodies.

** Magit

   Git is [[http://emacswiki.org/emacs/Git][already part of Emacs]]. However, [[http://philjackson.github.com/magit/magit.html][Magit]] is sweet.
   Don't believe me? Check out [[https://www.youtube.com/watch?v=vQO7F2Q9DwA][this video]].

   #+BEGIN_SRC elisp
     (use-package magit
       :ensure t
       :commands magit-status magit-blame
       :init
       (defadvice magit-status (around magit-fullscreen activate)
         (window-configuration-to-register :magit-fullscreen)
         ad-do-it
         (delete-other-windows))
       :config
       (setq magit-branch-arguments nil
             ;; use ido to look for branches
             magit-completing-read-function 'magit-ido-completing-read
             ;; don't put "origin-" in front of new branch names by default
             magit-default-tracking-name-function 'magit-default-tracking-name-branch-only
             magit-push-always-verify nil
             ;; Get rid of the previous advice to go into fullscreen
             magit-restore-window-configuration t)

       ;; Tell git to prompt me for my username/password when using the Open SSH protocol
       (setenv "GIT_ASKPASS" "git-gui--askpass")
       ;; Set the ssh variables for use at work
       (when (and (eq system-type 'windows-nt) (string= user-login-name ms/username))
         (setenv "SSH_AGENT_PID" "1032")
         (setenv "SSH_AUTH_SOCK" (concat (getenv "HOME") "/.ssh-socket")))

       :bind ("C-x g" . magit-status))
   #+END_SRC

   I like having Magit to run in a /full screen/ mode, and add the
   above =defadvice= idea from [[https://github.com/magnars/.emacs.d/blob/master/setup-magit.el][Sven Magnars]]. For a cheat-sheet of the
   multitude of available Magit commands check out this website from
   [[http://daemianmack.com/magit-cheatsheet.html][Damian Mack]].

   When at work we use gerrit for code review. Thanks to
   the [[https://github.com/terranpro/magit-gerrit][magit-gerrit]] project I can use this as well.

   #+BEGIN_SRC elisp
     (use-package magit-gerrit
       :ensure t
       :config
       (setq magit-gerrit-ssh-creds ms/gerrit_id))
   #+END_SRC

** LaTeX

   For any kind of publication one should use LaTeX. You ask why? Well,
   I don't think you deserve the answer. To make editing LaTeX source
   code easier I use the [[https://www.gnu.org/software/auctex/][aucTeX]] package.

   #+BEGIN_SRC elisp
     (use-package auctex
       :ensure t           ; Make sure it is installed
       :pin gnu            ; Make sure we take the one from the gnu archive
       :mode ("\\.tex\\'" . latex-mode)
       :commands (latex-mode LaTeX-mode plain-tex-mode)
       :bind ("<f9> m" . helm-insert-latex-math)
       :init             ; Some functionality to be loaded befor auctex fires up
       (progn
         (add-hook 'LaTeX-mode-hook #'LaTeX-preview-setup)
         (add-hook 'LaTeX-mode-hook #'turn-on-reftex)
         (add-hook 'LaTeX-mode-hook #'LaTeX-math-mode)
         (add-hook 'LaTeX-mode-hook #'turn-on-auto-fill)
         (add-hook 'LaTeX-mode-hook #'yas-minor-mode-on)
         (setq TeX-auto-save t
               TeX-parse-self t
               TeX-quote-after-quote nil
               TeX-PDF-mode t)
         (setq-default TeX-master nil))
       )
   #+END_SRC

   I use LaTeX and the Tikz/PGFplots package a lot to create beautiful
   drawing.  I used to compile the =.tex= file, go to the terminal and
   then use either ImageMagick or Ghostscript to create an image in
   the desired format. Since this is Emacs EVERYTHING can be
   customized.  The following code will add the option to create a PNG
   file from the PDF with either ImageMagick or Ghostscript depending
   on the system I am on:

   #+BEGIN_SRC elisp
     (setq TeX-command-list
             '(("TeX"
                "%(PDF)%(tex) %(file-line-error) %(extraopts) %`%S%(PDFout)%(mode)%' %t"
                TeX-run-TeX nil (plain-tex-mode ams-tex-mode texinfo-mode)
                :help "Run plain TeX")
               ("LaTeX"
                "%`%l%(mode)%' %t"
                TeX-run-TeX nil (latex-mode doctex-mode)
                :help "Run LaTeX")
               ("Makeinfo"
                "makeinfo %(extraopts) %t"
                TeX-run-compile nil (texinfo-mode)
                :help "Run Makeinfo with Info output")
               ("Makeinfo HTML"
                "makeinfo %(extraopts) --html %t"
                TeX-run-compile nil (texinfo-mode)
                :help "Run Makeinfo with HTML output")
               ("AmSTeX"
                "amstex %(PDFout) %(extraopts) %`%S%(mode)%' %t"
                TeX-run-TeX nil (ams-tex-mode)
                :help "Run AMSTeX")
               ("ConTeXt"
                "%(cntxcom) --once --texutil %(extraopts) %(execopts)%t"
                TeX-run-TeX nil (context-mode)
                :help "Run ConTeXt once")
               ("ConTeXt Full"
                "%(cntxcom) %(extraopts) %(execopts)%t"
                TeX-run-TeX nil (context-mode)
                :help "Run ConTeXt until completion")
               ("BibTeX"
                "bibtex %s"
                TeX-run-BibTeX nil t
                :help "Run BibTeX")
               ("Biber"
                "biber %s"
                TeX-run-Biber nil t
                :help "Run Biber")
               ("View"
                "%V"
                TeX-run-discard-or-function t t
                :help "Run Viewer")
               ("Print"
                "%p"
                TeX-run-command t t
                :help "Print the file")
               ("Queue"
                "%q"
                TeX-run-background nil t
                :help "View the printer queue"
                :visible TeX-queue-command)
               ("File"
                "%(o?)dvips %d -o %f "
                TeX-run-dvips t t
                :help "Generate PostScript file")
               ("Dvips"
                "%(o?)dvips %d -o %f "
                TeX-run-dvips nil t
                :help "Convert DVI file to PostScript")
               ("Dvipdfmx"
                "dvipdfmx %d"
                TeX-run-dvipdfmx nil t
                :help "Convert DVI file to PDF with dvipdfmx")
               ("Ps2pdf"
                "ps2pdf %f"
                TeX-run-ps2pdf nil t
                :help "Convert PostScript file to PDF")
               ("Index"
                "makeindex %s"
                TeX-run-index nil t
                :help "Run makeindex to create index file")
               ("Xindy"
                "texindy %s"
                TeX-run-command nil t
                :help "Run xindy to create index file")
               ("Check"
                "lacheck %s" TeX-run-compile nil (latex-mode)
                :help "Check LaTeX file for correctness")
               ("ChkTeX"
                "chktex -v6 %s"
                TeX-run-compile nil (latex-mode)
                :help "Check LaTeX file for common mistakes")
               ("Spell"
                "(TeX-ispell-document \"\")"
                TeX-run-function nil t
                :help "Spell-check the document")
               ("Clean"
                "TeX-clean"
                TeX-run-function nil t
                :help "Delete generated intermediate files")
               ("Clean All"
                "(TeX-clean t)"
                TeX-run-function nil t
                :help "Delete generated intermediate and output files")
               ("Other"
                ""
                TeX-run-command t t
                :help "Run an arbitrary command")
               ))

     (cond ((eq system-type 'gnu/linux)
            (add-to-list
             'TeX-command-list
             '("PNG"
               "convert %s.pdf %s.png"
               TeX-run-command
               nil                          ; ask for confirmation
               t                            ; active in all modes
               :help "Convert PDF to PNG")))
           ((eq system-type 'windows-nt)
            (add-to-list
             'TeX-command-list
             '("PNG"
               "gswin64c -q -dSAFER -dNOPAUSE -dBATCH -sDEVICE=png16m -r600 -sOutputFile#%s.png -f %s.pdf"
               TeX-run-command
               nil                          ; ask for confirmation
               t                            ; active in all modes
               :help "Convert PDF to PNG"))))
   #+END_SRC

   This had to be a little longer because for some reason changing the
   variable will only work with the customize menu. And I don't want
   to repeat the setup on my other workstations.

** RefTeX

   Throughout the years I have read quite a few papers.  I use
   [[http://www.jabref.org/][JabRef]] to organize all of my bibliography entries. To excess the
   entries from within emacs, especially when working on a paper with
   the auctex mode.

   #+BEGIN_SRC elisp
     (use-package reftex
       :commands turn-on-reftex
       :init
       (setq reftex-plug-into-AUCTeX t)
       (setq reftex-default-bibliography '("~/Bibliography/library.bib"))
       (setq reftex-bibliography-commands
             '("bibliography" "nobibliography" "addbibresource")))
   #+END_SRC

   Every once in awhile I like to include citations in my orgmode
   files. To use the power of reftex I need to make a few
   modifications. The idea and part of the documentation are stolen
   from [[https://tincman.wordpress.com/2011/01/04/research-paper-management-with-emacs-org-mode-and-reftex/][here]] and [[http://blog.modelworks.ch/?p=379][here]].

   #+BEGIN_SRC elisp :tangle no
     (defun org-mode-reftex-setup ()
       (load-library "reftex")
       (and (buffer-file-name) (file-exists-p (buffer-file-name))
            (progn
              ;enable auto-revert-mode to update reftex when bibtex file changes on disk
              (global-auto-revert-mode t)
              (reftex-parse-all)
              ;add a custom reftex cite format to insert links
              (reftex-set-cite-format
               '((?b . "[[bib:%l][%l-bib]]")
                 (?p . "[[papers:%l][%l-paper]]")
                 (?t . "%t")
                 (?h . "** %t\n:PROPERTIES:\n:Custom_ID: %l\n:END:\n[[papers:%l][%l-paper]]")))))
       (define-key org-mode-map (kbd "C-c )") 'reftex-citation))

     (add-hook 'org-mode-hook 'org-mode-reftex-setup)
   #+END_SRC

   Lastly, org-mode needs a few things to pull all this together. The
   first and most important is importing the bibtex file. RefTeX looks
   for a LaTeX \bibliography tag anywhere in the file or uses the
   default bibliography I specified when initializing the RefTeX
   package. To specify a bibliography specifically for the current
   file I add the =\bibliography{}= command as an org-mode comment at
   the beginning of the file:

   #+BEGIN_EXAMPLE
     # \bibliography{~/Bibliography/library.bib}
   #+END_EXAMPLE

   The other thing needed are link abbreviations. While you could
   hardcode this into your citation formats, I prefer to put
   abbreviations in for the citation formats.

   #+BEGIN_SRC elisp :tangle no
     (setq org-link-abbrev-alist
           '(("bib" . "~/Bibliography/library.bib::%s")
             ("datasheet" . "~/Datasheets/::%s.pdf")
             ("notes" . "~/research/org/notes.org::#%s")
             ("papers" . "~/Bibliography/documents/%s.pdf")))
   #+END_SRC

   These can be easily overridden in an org-mode file, which I
   actually do for the org-mode file I store the actual entries in. If
   I left it as is, following a ‚Äúnotes‚Äù link in this org-mode file
   would open the same file in a new window and jump to the entry in
   that one. Not quite what we want. This is where I override it in
   the local file by adding this to my heading.

   #+BEGIN_EXAMPLE
     #+LINK: notes #%s
   #+END_EXAMPLE

   Now, if I follow a ‚Äúnotes‚Äù link in the entries file, it jumps to
   that entry in the same frame, while following a ‚Äúnotes‚Äù link in
   another org-mode file (or using my new reftex search addition) will
   open this file in a new frame and jump to the entry.
** Org-Ref

   I don't know if I should have put this into my [[file:emacs-org.org][org-mode init]]
   file. For right now I keep it here since I configure RefTeX after I
   configure org-mode. The configurations are taken from the [[https://github.com/jkitchin/org-ref][org-ref]]
   git-hub repository.

   #+BEGIN_SRC elisp
     (use-package org-ref
       :ensure t
       :config
       (setq org-ref-bibliography-notes "~/personal/bib_notes.org"
             org-ref-default-bibliography '("~/Bibliography/library.bib")
             org-ref-pdf-directory "~/Bibliography/documents/")

       ;; For helm-bibtex citation completion
       (setq bibtex-completion-bibliography "~/Bibliography/library.bib"
             bibtex-completion-library-path "~/Bibliography/documents"
             bibtex-completion-notes-path "~/Bibliography/helm-bibtex-notes")

       ;; Depending on the operating system I am on I need to set different
       ;; functions for opening PDF documents
       (cond
        ((eq system-type 'windows-nt)        ; Windows
         (setq bibtex-completion-pdf-open-function
               (lambda (fpath)
                 (start-process "open" "*open*" "SumatraPDF" fpath ))))
        ((eq system-type 'gnu/linux)         ; Linux (Ubuntu in my case)
         (setq bibtex-completion-pdf-open-function
               (lambda (fpath)
                 (start-process "open" "*open*" "evince" fpath))))
        ((eq system-type 'darwin)            ; Mac OS X
         (setq bibtex-completion-pdf-open-function
               (lambda (fpath)
                 (start-process "open" "*open*" "open" fpath)))))
       )
   #+END_SRC

** Graphviz and PlantUML

   Install the [[http://www.graphviz.org/][Graphviz]] and [[http://plantuml.sourceforge.net/download.html][PlantUML]] projects using the dnf package
   manager:

   #+BEGIN_SRC sh :tangle no
     sudo dnf install graphviz
     sudo dnf install plantuml
   #+END_SRC

   Load the [[http://ppareit.github.com/graphviz-dot-mode/][mode for Graphviz]]:

   #+BEGIN_SRC elisp
     (use-package graphviz-dot-mode
        :ensure t)
   #+END_SRC

   and load the [[https://github.com/wildsoul/plantuml-mode][mode for PlantUML]] and reference its jar:

   #+BEGIN_SRC elisp
     (let ((plantuml-jar (car (file-expand-wildcards "~/Git/Scripts/plantuml.jar"))))
       (ignore-errors
         (use-package plantuml-mode
           :if plantuml-jar
           :init
           (setq plantuml-jar-path plantuml-jar
                 org-plantuml-jar-path plantuml-jar))))
   #+END_SRC

* Applications
** TODO Web Browsing
** EShell

   See [[file:emacs-eshell.org][emacs-eshell.el]] for details of configuring and using EShell.

   #+BEGIN_SRC elisp
     (require 'init-eshell)
   #+END_SRC

* Technical Artifacts

** Configure the Graphical Settings

   If we are running in a windowed environment where we can set up
   fonts and whatnot, call the 'mac' stuff... which will still work
   for Linux too.

   #+BEGIN_SRC elisp
     (if (window-system)
        (require 'init-client)
      (require 'init-server))
   #+END_SRC


   After the first load, we can reload this with a require:

   #+BEGIN_SRC elisp
     (provide 'init-main)
   #+END_SRC

   Before you can build this on a new system, make sure that you put
   the cursor over any of these properties, and hit: =C-c C-c=

#+DESCRIPTION: A literate programming version of my Emacs Initialization script, loaded by the .emacs file.
#+PROPERTY:    results silent
#+PROPERTY:    header-args:sh  :tangle no
#+PROPERTY:    tangle ~/.emacs.d/elisp/init-main.el
#+PROPERTY:    eval no-export
#+PROPERTY:    comments org
#+OPTIONS:     num:nil toc:nil todo:nil tasks:nil tags:nil
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+INFOJS_OPT:  view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
