#+TITLE:  Emacs Configuration File
#+AUTHOR: Markus Sievers
#+EMAIL:  markussievers88@gmail.com
#+DATE:   2016-05-19
#+TAGS:   emacs

* Introduction

  This is my =.emacs= file ... well, I took Howard Abrams emacs.org as
  an example and created this top-level init-file. Through Howard I
  was introduced to [[http://www.literateprogramming.com/][literate_programming]] using Emacs' [[http://www.orgmode.org][orgmode]]. I will
  try to provide the links as best as I can to show from where I stole
  my notes.

** Emacs Executable

   If you want to install Emacs on Ubuntu all you have to do is run
   this from the terminal to install the pre-compiled version
   included in the Ubuntu repository:

   #+BEGIN_SRC sh :tangle no
     sudo apt-get update
     sudo apt-get install emacs -y
   #+END_SRC

   You may, of course, get the source code and compile it
   yourself. But for me using the pre-compiled version is sufficient
   because I do not have to fight around with dependency issues.

   In case you are one of the unfortunate ones that have use a windows
   operating system you have the option to download an Emacs
   compilation from one of the gnu mirrors. The
   [[http://www.gnu.org/software/emacs/manual/html_mono/efaq-w32.html][GNU_Emacs_FAQ_for_MS_Windows]] section on the [[http://www.gnu.org/software/emacs/manual/][GNU_Emacs_Online_Manual]]
   web page will lead to to the nearest mirror where you can download
   the latest compiled version of Emacs. Once you downloaded and
   unpacked the /Zip/ file you have to do a few more modifications:

      1) Rename and copy the unpacked Emacs folder to your /Program
         Files/ or /Program Files (x86)/ folder.
      2) Add the /bin/ sub-directory to the /PATH/ variable.
      3) Create the /HOME/ variable in your windows variables pointing
         to your /$HOME/ directory (Typically located at C:/Users/username/)
      4) Within the /bin/ sub-directory execute the /addpm.exe/
         program as an administrator to "install" Emacs.
      5) I like to enable the *Run as administrator* option for the
         /emacs.exe/ and /runemacs.exe/ file such that I have root
         access rights when running commands from within Emacs.
   
   The previous steps are also nicely visualized in this YouTube
   tutorial:

   [[https://youtu.be/g6kgF5ZAf44][How_to_Install_Emacs_editor_in_Windows]]
      
** Loading this File

   To "load" the contents of this file, add the following to
   =$HOME/.emacs=:

   #+BEGIN_SRC elisp :tangle no
     ;; Load our Literate Programming version of our Dot Emacs
     ;; file, from ~/Path_to/Dot-Files/emacs.org
     (load-file "~/.emacs.d/elisp/init-main.el")

     (server-start)   
   #+END_SRC

* General Settings
** My Directory Location

   Normally, the =user-emacs-directory= stores everything in a
   =.emacs.d= directory in the home directory, however, some Emacs
   flavors (e.g. Aquamacs) overrides that, and since I now feel the
   need to use these settings for both editors (sure feels like XEmacs
   all over again).

   Any way, I have a new global variable for that:

   #+BEGIN_SRC elisp
     (defconst ms/emacs-directory (concat (getenv "HOME") "/.emacs.d/"))

     (defun ms/emacs-subdirectory (d) (expand-file-name d ms/emacs-directory)) 
   #+END_SRC

** Directory Structure

   In case this is the first time running this on a computer, we need
   to make sure the following directories have been created.

   #+BEGIN_SRC elisp
     (let* ((subdirs '("elisp" "backups" "snippets" "ac-dict"))
            (fulldirs (mapcar (lambda (d) (ms/emacs-subdirectory d)) subdirs)))
       (dolist (dir fulldirs)
         (when (not (file-exists-p dir))
           (message "Make directory: %s" dir)
           (make-directory dir))))
   #+END_SRC

** Customization Section
   
   While I would rather program my configurations, sometimes the Emacs
   menu system is "good enough", but I want it in its own file:

   #+BEGIN_SRC elisp
     (setq custom-file (expand-file-name "custom.el" ms/emacs-directory))
     (when (file-exists-p custom-file)
       (load custom-file))
   #+END_SRC

** Setting up the Load Path

   Extra packages not available via the package manager go in my
   personal stash at: =$HOME/.emacs.d/elisp=

   #+BEGIN_SRC elisp
     (add-to-list 'load-path (ms/emacs-subdirectory "elisp"))
   #+END_SRC

   Load up my special collection of enhancements to Emacs Lisp:

   #+BEGIN_SRC elisp
     (require 'cl)
     (require 'init-support)
   #+END_SRC
   
* Package Initialization
** Package Manager
   
   Emacs has become like every other operating system, and now has a
   [[http://tromey.com/elpa/][package manager]] with its own collection repository, but since it is
   so conservative, we need to add more repositories to get all the
   sweet goodness, I demand. But before I can get a hold of all those
   glorious packages I need to make sure that I can get through the
   proxy at work, but only at work:

   #+BEGIN_SRC elisp
     ;; Make sure that we can get through the proxy at work, 
     ;; but only at work
     (if (string= user-login-name 'sieversm)
         (setq url-proxy-services
              '(("http" . "127.0.0.1:3128")
                ("https" . "127.0.0.1:3128")))
      'false)
   #+END_SRC

   Now I can get to all the juicy stuff:

   #+BEGIN_SRC elisp
     (require 'package)

     (setq package-archives '(("org"       . "http://orgmode.org/elpa/")
                              ("gnu"       . "http://elpa.gnu.org/packages/")
                              ("melpa"     . "http://melpa.org/packages/")))

     (package-initialize)
   #+END_SRC

   These is also the *marmalade* repository, but I have only bad
   things about it. Thus I am not including it here. If you want to
   add the following to the previous archive list:

   #+BEGIN_SRC elisp :tangle no
     ("marmalade" . "http://marmalade-repo.org/packages/")
   #+END_SRC
   
   The package management system doesn't come with a
   programmatic way to specify what packages /should/ be
   installed. Here is my solution until I convert to [[Use-Package][use-package]].

   #+BEGIN_SRC elisp
     (defun packages-install (packages)
       "Given a list of packages, this will install them from the standard locations."
       (let ((to-install (inverse-filter 'package-installed-p packages)))
         (when to-install
           (package-refresh-contents)
           (dolist (it to-install)
               (package-install it)
           (delete-other-windows)))))
   #+END_SRC

** Use-Package

   Using [[https://github.com/jwiegley/use-package][use-package]] to automatically install certain packages, as
   well as the ease of lazily loading them.

   #+BEGIN_SRC elisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (require 'use-package)
   #+END_SRC
 
* Variables

  Generall setting about me that other packages can use. The biggest
  problem is guessing my email address based on what computer I am
  using:

  #+BEGIN_SRC elisp
    (if (equal "markus" user-login-name)
        (setq user-mail-address "markussievers88@gmail.com") ; home
      (setq user-mail-address "markus.sievers@k-ai.at"))     ; work
  #+END_SRC
  
** Tabs vs Spaces

   I have learned to distrust tabs in my source code, so let's make
   sure that we only have spaces. See [[http://ergoemacs.org/emacs/emacs_tabs_space_indentation_setup.html][this discussion]] for details.

   #+BEGIN_SRC elisp
     (setq-default indent-tabs-mode nil)
     (setq tab-width 2)
   #+END_SRC

   Make tab key do indent first then completion.

   #+BEGIN_SRC elisp
     (setq-default tab-always-indent 'complete)
   #+END_SRC

** TODO Encrypting Files

   This section includes the file encryption using pgp. Since I have
   no clue about it yet I will leave this for later.
   
* Display Settings

  I may not have been using Emacs for as long as Howard Abrams has,
  but I do appreciate a minimalist approach to its display as well. To
  clear up the user interface a little be the following settings do
  some of the essential stuff:

  #+BEGIN_SRC elisp
    (setq initial-scratch-message "") ;; Uh, I know what Scratch is for
    (setq visible-bell t)             ;; Get rid of the beeps

    (when (window-system)
      (tool-bar-mode 0)               ;; Toolbars were only cool with XEmacs
      (when (fboundp 'horizontal-scroll-bar-mode)
        (horizontal-scroll-bar-mode -1))
      (scroll-bar-mode -1))            ;; Scrollbars are waste screen estate
  #+END_SRC

** TODO Create List Display Settings
   Most of the display settings will be stored in their own org files
   and listed here.

** Mode Line

   Howard Abrams [[file:emacs-mode-line.org][mode-line code]] is a little more complex and deserved
   its own file.  To initialize and use it use the following code:

   #+BEGIN_SRC elisp
     (require 'init-mode-line)
   #+END_SRC

** Whitespace Mode

   You don't want this on all the time, but nice to turn it on every
   now and then:

   #+BEGIN_SRC elisp
     (use-package whitespace
       :bind ("C-c T w" . whitespace-mode)
       :init
       (setq whitespace-line-column nil
             whitespace-display-mappings '((space-mark 32 [183] [46])
                                           (newline-mark 10 [9166 10])
                                           (tab-mark 9 [9654 9] [92 9])))
       :config
       (set-face-attribute 'whitespace-space       nil :foreground "#666666" :background nil)
       (set-face-attribute 'whitespace-newline     nil :foreground "#666666" :background nil)
       (set-face-attribute 'whitespace-indentation nil :foreground "#666666" :background nil)
       :diminish whitespace-mode)
   #+END_SRC

** Fill Mode
   
   Automatically wrapping when you get to the end of a line (or the
   fill-region):

   #+BEGIN_SRC elisp
     (use-package fill
       :bind ("C-c T f" . auto-fill-mode)
       :init (add-hook 'org-mode-hook 'turn-on-auto-fill)
       :diminish auto-fill-mode)
   #+END_SRC

* TODO Key Bindings
** Hydra Sequences

   I’m starting to appreciate the [[https://github.com/abo-abo/hydra][Hydra project]].

   #+BEGIN_SRC elisp
     (use-package hydra
       :ensure t
       :config
       (hydra-add-font-lock))
   #+END_SRC

   Easily manipulate the size of the windows using the arrow keys in a
   particular buffer window.

   #+BEGIN_SRC elisp
     (require 'windmove)

     (defun hydra-move-splitter-left (arg)
       "Move window splitter left."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'right))
           (shrink-window-horizontally arg)
         (enlarge-window-horizontally arg)))

     (defun hydra-move-splitter-right (arg)
       "Move window splitter right."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'right))
           (enlarge-window-horizontally arg)
         (shrink-window-horizontally arg)))

     (defun hydra-move-splitter-up (arg)
       "Move window splitter up."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'up))
           (enlarge-window arg)
         (shrink-window arg)))

     (defun hydra-move-splitter-down (arg)
       "Move window splitter down."
       (interactive "p")
       (if (let ((windmove-wrap-around))
             (windmove-find-other-window 'up))
           (shrink-window arg)
         (enlarge-window arg)))

     (defhydra hydra-splitter (global-map "<f9>")
       "splitter"
       ("<left>" hydra-move-splitter-left)
       ("<down>" hydra-move-splitter-down)
       ("<up>" hydra-move-splitter-up)
       ("<right>" hydra-move-splitter-right))
   #+END_SRC

   Other Hydra sequences are associated with the package they control.
** Displaying Command Sequences

   Many command sequences may be logical, but who can remember them
   all? Use [[https://github.com/kai2nenobu/guide-key][guide-key]] to display the final function name. This isn't
   as nice as Hydra, but useful for built-in key sequences:

   #+BEGIN_SRC elisp
     (use-package guide-key
       :ensure t
       :init    (setq guide-key/guide-key-sequence
                      '("C-x r"     ; rectanges and registers
                        "C-x 4"     ; window commands
                        "M-s h"     ; hi-lock highlighting
                        "C-x w"     ; alternative to M-s ...
                        "C-c @"     ; hs-hide-show mode
                        "C-c p"     ; projectile
                        "<f2>"
                        "<f9>"
                        (org-mode "C-c C-x")))
       :config  (guide-key-mode 1)
       :diminish guide-key-mode)
   #+END_SRC

** Function Key Definitions
   
   Emacs has never seen a need for function keys, and I agree...for
   the most part. For things really /away from the flow/, they don't
   seem to bad. But what are those?

   - *F1* - Help? Isn't Control-H good enough?
   - *F2* - Special odd, little-used characters that I have to think
            about before remembering what its binding.
   - *F3* - Define a keyboard macro
   - *F4* - Replay a keyboard macro
   - *F5* - Use org-mode’s Mark Ring feature globally
   - *F6* - Open to temporary, changeable commands...
   - *F7* - Switch to another window ... Control goes the other way.
   - *F8* - Switch to buffer
   - *F9* - My extension (replacement?) for =C-c= for changing colors
     and other odd bindings that I actually don't use that often.

   #+BEGIN_SRC elisp
     (global-set-key (kbd "<f5>") 'org-mark-ring-push)
     (global-set-key (kbd "C-<f5>") 'org-mark-ring-goto)
     (global-set-key (kbd "<f7>") 'other-window)
     (global-set-key (kbd "C-<f7>") (lambda () (interactive) (other-window -1)))
   #+END_SRC

*** F2 and F9 Helpers

    The F9 prefix is scattered about my config files.

    #+BEGIN_SRC elisp
      (define-prefix-command 'personal-global-map)
      (global-set-key (kbd "<f9>") 'personal-global-map)
    #+END_SRC

    Unlike the *F9* bindings, all the *F2* key-bindings happen in a
    single [[file:emacs-f2.org][library file]]:

    #+BEGIN_SRC elisp
      (require 'init-f2)
    #+END_SRC

** Highlighting and Narrowing

   I like the ability to highlight random text.

   - =M-s h .= :: highlight-symbol-at-point
   - =M-s h l= :: highlight-lines-matching-regexp
   - =M-s h p= :: highlight-phrase
   - =M-s h r= :: highlight-regexp
   - =M-s h u= :: unhighlight-regexp

   May get specific highlights automatically for certain files. We
   begin by highlighting lines in *.log files.

   #+BEGIN_SRC elisp
     (defun ms/highlite-logs ()
       "Highlight certain lines in specific files. Currently, only log files are supported."
       (interactive)
       (when (equal "log" (file-name-extension (buffer-file-name)))
             (hi-lock-mode 1)
             (highlight-lines-matching-regexp "ERROR:" 'hi-red-b)
             (highlight-lines-matching-regexp "NOTE:" 'hi-blue-b)))
   #+END_SRC

   The condition in this function that checks for the =log= extension,
   allows me to hook it to the loading of any file:

   #+BEGIN_SRC elisp :tangle no
     (add-hook 'find-file-hook 'ms/highlite-logs)
   #+END_SRC

   Turn on specific word groupings for specific occasions. We begin
   with highlighting keywords I use during note-taking sessions at
   the end of a sprint.

   #+BEGIN_SRC elisp
     (defun ms/sprint-retrospective-highlighting ()
       "Highlights the good, the bad and the improvements to make when taking notes."
       (interactive)
       (hi-lock-mode t)
       (highlight-lines-matching-regexp "^   [-*] " 'hi-black-b)
       (highlight-phrase "TODO:?" 'hi-black-b)
       (highlight-regexp "(?Good)?:?" 'hi-green-b)
       (highlight-regexp "(?Bad)?:?" 'hi-red-b)
       (highlight-regexp "Imp\\(rove\\)?:" 'hi-blue-b))
   #+END_SRC

   This works really well with other commands, including
   [[https://github.com/Bruce-Connor/fancy-narrow][fancy-narrow]], where I can visually high-light a section of a
   buffer. Great for code-reviews and other presentations.

   #+BEGIN_SRC elisp
     (use-package fancy-narrow
       :ensure t
       :config
       (defun ms/highlight-block ()
         "Highlights a 'block' in a buffer defined by the first blank
          line before and after the current cursor position. Uses the
          'fancy-narrow' mode to high-light the block."
         (interactive)
         (let (cur beg end)
           (setq cur (point))
           (setq end (or (re-search-forward  "^\s*$" nil t) (point-max)))
           (goto-char cur)
           (setq beg (or (re-search-backward "^\s*$" nil t) (point-min)))
           (fancy-narrow-to-region beg end)
           (goto-char cur)))

       (defun ms/highlight-section (num)
         "If some of the buffer is highlighted with the `fancy-narrow'
          mode, then un-highlight it by calling `fancy-widen'.

          If region is active, call `fancy-narrow-to-region'.

          If NUM is 0, highlight the current block (delimited by blank
          lines). If NUM is positive or negative, highlight that number
          of lines.  Otherwise, called `fancy-narrow-to-defun', to
          highlight current function."
         (interactive "p")
         (cond
          ((fancy-narrow-active-p)  (fancy-widen))
          ((region-active-p)        (fancy-narrow-to-region (region-beginning) (region-end)))
          ((= num 0)                (ms/highlight-block))
          ((= num 1)                (fancy-narrow-to-defun))
          (t                        (progn (ms/expand-region num)
                                           (fancy-narrow-to-region (region-beginning) (region-end))))))

       :bind ("C-M-+" . ms/highlight-section))
   #+END_SRC

   This nifty function from [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Endless Parenthesis]] is a nice replacement
   for many other narrowing keybindings that I use:

   #+BEGIN_SRC elisp
     (defun narrow-or-widen-dwim (p)
       "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
     Intelligently means: region, subtree, or defun, whichever applies
     first.

     With prefix P, don't widen, just narrow even if buffer is already
     narrowed."
       (interactive "P")
       (declare (interactive-only))
       (cond ((and (buffer-narrowed-p) (not p)) (widen))
             ((region-active-p)
              (narrow-to-region (region-beginning) (region-end)))
             ((derived-mode-p 'org-mode) (org-narrow-to-subtree))
             (t (narrow-to-defun))))

     (global-set-key (kbd "C-x n x") 'narrow-or-widen-dwim)
   #+END_SRC
   
** Jumping to Windows

  Set up [[https://github.com/abo-abo/ace-window][ace-window]] mode:

  #+BEGIN_SRC elisp
    (use-package ace-window
      :ensure t
      :init
        (setq aw-keys '(?a ?s ?d ?f ?j ?k ?l ?o))
        (global-set-key (kbd "C-x o") 'ace-window)
      :diminish ace-window-mode)
  #+END_SRC

** Selecting a Buffer
   I like =IDO= for switching buffers since I typically know what I'm after:

   #+BEGIN_SRC elisp
    (global-set-key (kbd "<f8>") 'ido-switch-buffer)
    (global-set-key (kbd "S-<f8>") 'ibuffer)
   #+END_SRC

   I like [[https://github.com/KMahoney/kpm-list][kpm-list]] a bit better than =ibuffer=, but I really don’t use
   either more than =ido-switch-buffer=. Still:

   #+BEGIN_SRC elisp
    (use-package kpm-list
      :ensure t
      :bind ("S-<f8>" . kpm-list)
            ("C-x C-b" . kpm-list))
   #+END_SRC

* TODO Loading and Finding Files
** Dired Options

   Between =M-!= and starting [[Eshell][Eshell]], comes =dired= (=C-x d=).

   #+BEGIN_SRC elisp
     (setq ls-lisp-use-insert-directory-program nil)
   #+END_SRC

   This enhancement to dired hides the ugly details until you hit
   '(' and shows the details with ')'. I also change the [...] to a
   simple asterisk.

   #+BEGIN_SRC elisp
     (use-package dired-details
       :ensure t
       :init   (setq dired-details-hidden-string "* ")
       :config (dired-details-install))
   #+END_SRC

   The ability to create a dired buffer based on searching for files
   in a directory tree with =find-name-dired= is fantastic. The
   [[http://www.masteringemacs.org/articles/2011/03/25/working-multiple-files-dired/][following magic]] optimizes this approach:

   #+BEGIN_SRC elisp
     (use-package find-dired
        :ensure t
        :init (setq find-ls-option '("-print0 | xargs -0 ls -od" . "-od")))
   #+END_SRC

   The [[http://pragmaticemacs.com/emacs/quickly-preview-images-and-other-files-with-peep-dired/][peep project]] allows you to preview files before loading them
   into a dedicated buffer:

   #+BEGIN_SRC elisp
     (use-package peep-dired
       :defer t ; don't access `dired-mode-map' until `peep-dired' is loaded
       :bind (:map dired-mode-map
                   ("P" . peep-dired)))
   #+END_SRC

   The [[http://www.masteringemacs.org/articles/2014/04/10/dired-shell-commands-find-xargs-replacement/][dired-x project]] seems useful:

   #+BEGIN_SRC elisp
     (require 'dired-x)
   #+END_SRC

** IDO (Interactively DO Things)

   According to [[http://www.masteringemacs.org/articles/2010/10/10/introduction-to-ido-mode/][Mickey]], IDO is the greatest thing.

   #+BEGIN_SRC elisp
     (use-package ido
       :ensure t
       :init  (setq ido-enable-flex-matching t
                    ido-ignore-extensions t
                    ido-use-virtual-buffers t
                    ido-everywhere t)
       :config
       (ido-mode 1)
       (ido-everywhere 1)
       (add-to-list 'completion-ignored-extensions ".pyc"))
   #+END_SRC

   Add to IDO, the [[https://github.com/lewang/flx][FLX]] package:

   #+BEGIN_SRC elisp
     (use-package flx-ido
        :ensure t
        :init (setq ido-enable-flex-matching t
                    ido-use-faces nil)
        :config (flx-ido-mode 1))
   #+END_SRC

   According to [[https://gist.github.com/rkneufeld/5126926][Ryan Kneufeld]], we could make IDO work vertically,
   which is much easier to read. For this, I use [[https://github.com/gempesaw/ido-vertical-mode.el][ido-vertically]]:

   #+BEGIN_SRC elisp
     (use-package ido-vertical-mode
       :ensure t
       :init               ; I like up and down arrow keys:
       (setq ido-vertical-define-keys 'C-n-C-p-up-and-down)
       :config
       (ido-vertical-mode 1))
   #+END_SRC

** Helm

   Obviously, Helm would be helpful if I can learn all the bindings,
   so:

   #+BEGIN_SRC elisp
     (use-package helm
       :ensure t
       :init (add-to-list 'guide-key/guide-key-sequence "C-x c")
       (use-package helm-config))   ;; Binds C-x c to the helm bidness.
   #+END_SRC

   Re-read [[http://tuhdo.github.io/helm-intro.html][this essay on Helm]].

** Recent File List

   According to [[http://www.emacswiki.org/emacs-es/RecentFiles][this article]], Emacs already has the recent file
   listing available, just not turned on.

   #+BEGIN_SRC elisp
     (use-package recentf
       :init
       (setq recentf-max-menu-items 25)
       (setq recentf-auto-cleanup 'never)
       ;; (setq recentf-keep '(file-remote-p file-readable-p))
       (recentf-mode 1)
       :bind ("C-c f f" . recentf-open-files))
   #+END_SRC

   We do not want to stat all the files when Emacs starts up because
   files read by Tramp will slow down the start time.

** Backup Settings

   This setting moves all backup files to a central location.
   Got it from [[http://whattheemacsd.com/init.el-02.html][this page]].

   #+BEGIN_SRC elisp
     (setq backup-directory-alist
           `(("." . ,(expand-file-name
                      (ms/emacs-subdirectory "backups")))))
   #+END_SRC

   Make backups of files, even when they're in version control

   #+BEGIN_SRC elisp
     (setq vc-make-backup-files t)
   #+END_SRC

   And let’s make sure our files are saved if we wander off and
   defocus the Emacs application:

   #+BEGIN_SRC elisp
     (defun save-all ()
       "Saves all dirty buffers without asking for confirmation."
       (interactive)
       (save-some-buffers t))

     (add-hook 'focus-out-hook 'save-all)
   #+END_SRC

* Word Smithing
** Auto Insertion

   Just beginning to get a collection of templates to automatically
   insert if a blank file is loaded.

   #+BEGIN_SRC elisp
     (use-package autoinsert
       :init
       (setq auto-insert-directory (ms/emacs-subdirectory "templates/"))
       ;; Don't want to be prompted before insertion:
       (setq auto-insert-query nil)

       (add-hook 'find-file-hook 'auto-insert)
       (auto-insert-mode 1))
   #+END_SRC

   Add a =:config= section to configure static insertion, and add:

   #+BEGIN_SRC elisp :tangle no
     (define-auto-insert "\\.html?$" "default-html.html")
   #+END_SRC

   However, auto insertion requires entering data for particular fields,
   and for that Yasnippet is better, so in this case, we combine them:

   #+BEGIN_SRC elisp
     (defun ms/autoinsert-yas-expand()
       "Replace text in yasnippet template."
       (yas-expand-snippet (buffer-string) (point-min) (point-max)))
   #+END_SRC

   Now bind many of the templates for auto-insert and field expansion:

   #+BEGIN_SRC elisp
     (use-package autoinsert
       :config
       (define-auto-insert "\\.el$" ["default-lisp.el" ms/autoinsert-yas-expand])
       (define-auto-insert "\\.sh$" ["default-sh.sh" ms/autoinsert-yas-expand])
       (define-auto-insert "/bin/"  ["default-sh.sh" ms/autoinsert-yas-expand])
       (define-auto-insert "\\.html?$" ["default-html.html" ms/autoinsert-yas-expand]))
   #+END_SRC

** Auto Complete

   Using [[http://company-mode.github.io/][company-mode]] for all my auto completion needs.

   Like [[https://github.com/vspinu/company-math][this idea]] of being able to easily insert math
   symbols based on LaTeX keywords. Start typing a backslash.

   #+BEGIN_SRC elisp
     (use-package company
       :ensure t
       :init
       (add-hook 'after-init-hook 'global-company-mode)
       :config
       (add-to-list 'company-backends 'company-math-symbols-unicode)
       :diminish company-mode)
   #+END_SRC

   Take advantage of idle time by displaying some documentation
   using [[https://www.github.com/expez/company-quickhelp][company-quickhelp]] project.

   #+BEGIN_SRC elisp
     (use-package company-quickhelp
       :ensure t
       :config
       (company-quickhelp-mode 1))
   #+END_SRC

   This also requires [[https://github.com/pitkali/pos-tip/blob/master/pos-tip.el][pos-tip]].

** Yasnippets

   The [[https://github.com/capitaomorte/yasnippet][yasnippet project]] allows me to create snippets of code that
   can be brought into a file, based on the language.

   #+BEGIN_SRC elisp
     (use-package yasnippet
       :ensure t
       :init
       (yas-global-mode 1)
       :config
       (add-to-list 'yas-snippet-dirs (ms/emacs-subdirectory "snippets")))
   #+END_SRC

   *Note:*: the =snippets= directory contains directories for each
   mode, e.g.  =clojure-mode= and =org-mode=.

** Spelling Correction with Abbreviation Mode

   According to [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][this discussion]], we can correct a misspelled word
   with =C-x C-i= and it will use the abbreviation mode to
   automatically correct that word...as long as you misspell it the
   same way each time.

   #+BEGIN_SRC elisp
     (defun ms/ispell-word-then-abbrev (p)
       "Call `ispell-word'. Then create an abbrev for the correction made.
     With prefix P, create local abbrev. Otherwise it will be global."
       (interactive "P")
       (let ((bef (downcase (or (thing-at-point 'word) ""))) aft)
         (call-interactively 'ispell-word)
         (setq aft (downcase (or (thing-at-point 'word) "")))
         (unless (string= aft bef)
           (message "\"%s\" now expands to \"%s\" %sally"
                    bef aft (if p "loc" "glob"))
           (define-abbrev
             (if p global-abbrev-table local-abbrev-table)
             bef aft))))

     (global-set-key (kbd "C-x C-i") 'ms/ispell-word-then-abbrev)
   #+END_SRC

   Need to turn on the mode, but not necessarily show it:

   #+BEGIN_SRC elisp
     (use-package abbrev
       :bind ("C-c T a" . abbrev-mode)
       :init (setq save-abbrevs t)
             (setq-default abbrev-mode t)
       :diminish abbrev-mode)
   #+END_SRC

** Spell Checking

   I like spell checking with [[http://www.emacswiki.org/emacs/FlySpell][FlySpell]], which uses the built-in
   spell-check settings of [[https://www.gnu.org/software/ispell/][ispell]].

   The [[http://aspell.net][ASpell]] project is better supported than ISpell.

   #+BEGIN_SRC sh :tangle no
     brew install aspell
   #+END_SRC

   Start for all text modes (but not for log files):

   #+BEGIN_SRC elisp
     (use-package flyspell
       :ensure t
       :diminish flyspell-mode
       :init
       (add-hook 'prog-mode-hook 'flyspell-prog-mode)

       (dolist (hook '(text-mode-hook org-mode-hook))
         (add-hook hook (lambda () (flyspell-mode 1))))

       (dolist (hook '(change-log-mode-hook log-edit-mode-hook org-agenda-mode-hook))
         (add-hook hook (lambda () (flyspell-mode -1))))

       :config
       (if (eq system-type 'windows-nt)
           (setq ispell-program-name "c:/Program Files (x86)/Aspell/bin/aspell.exe")
         (setq ispell-program-name "aspell"))

       (setq ispell-dictionary "american" ; better for aspell
             ispell-extra-args '("--sug-mode=ultra" "--lang=en_US")
             ispell-list-command "--list")

       (add-to-list 'ispell-local-dictionary-alist '("american"
                                                     "[[:alpha:]]"
                                                     "[^[:alpha:]]"
                                                     "['‘’]"
                                                     t
                                                     ("-d" "en_US")
                                                     nil
                                                     utf-8)))
   #+END_SRC

   ASpell automatically configures a personal dictionary
   at =~/.aspell.en.pws=, so no need to configure that.

   Sometimes I would like to write some stuff in another language as
   well. For me that usually happens to be German. To change the
   dictionary, which I assume will not happen too many times, I have
   created the following sequence:

   #+BEGIN_SRC elisp
     (define-sequence 'dictionary-select-map "<f9> d" 'ispell-change-dictionary
       (list (list "e" "american")
             (list "a" "american")
             (list "d" "german")
             (list "g" "german")))
   #+END_SRC

* TODO Org-Mode

  See [[file:emacs-org.org][emacs-org-mode.el]] for details on my [[http://www.orgmode][Org-Mode]] settings.

  #+BEGIN_SRC elisp
    (require 'init-org-mode)
  #+END_SRC

  Add reftex support when within orgmode
  
* TODO LaTeX

  For any kind of publication one should use LaTeX. You ask why? Well,
  I don't think you deserve the answer.

  Create an =emacs-latex.org= file that includes all my settings from my
  previous =.emacs= file
  
* Technical Artifacts

** Setting up the Exec Path

   Make sure that =PATH= variable for finding binary files can is the
   same as what Emacs will look for binary files. This little magic,
   starts up a shell, gets its path, and then uses that for the
   =exec-path=:

   #+BEGIN_SRC elisp
     (when window-system
       (let ((path-from-shell (shell-command-to-string "/bin/bash -l -c 'echo $PATH'")))
         (setenv "PATH" path-from-shell)
         (setq exec-path (split-string path-from-shell path-separator))))
   #+END_SRC

** TODO Configure the Graphical Settings

   If we are running in a windowed environment where we can set up
   fonts and whatnot, call the 'mac' stuff... which will still work
   for Linux too.

   #+BEGIN_SRC elisp
     (if (window-system)
        (require 'init-client)
      (require 'init-server))
   #+END_SRC

** Load up the Local Configuration

   Before we finish, we need to check if there is a local file for us
   to load and evaluate.  We assume the local file has been tangled
   and provides the =init-local= key:

   #+BEGIN_SRC elisp
     (require 'init-local nil t)
   #+END_SRC

   After the first load, we can reload this with a require:

   #+BEGIN_SRC elisp
     (provide 'init-main)
   #+END_SRC

   Before you can build this on a new system, make sure that you put
   the cursor over any of these properties, and hit: =C-c C-c=

#+DESCRIPTION: A literate programming version of my Emacs Initialization script, loaded by the .emacs file.
#+PROPERTY:    results silent
#+PROPERTY:    header-args:sh  :tangle no
#+PROPERTY:    tangle ~/.emacs.d/elisp/init-main.el
#+PROPERTY:    eval no-export
#+PROPERTY:    comments org
#+OPTIONS:     num:nil toc:nil todo:nil tasks:nil tags:nil
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+INFOJS_OPT:  view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
